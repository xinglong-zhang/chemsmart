import logging
import os

from chemsmart.io.folder import BaseFolder

logger = logging.getLogger(__name__)


class XTBFolder(BaseFolder):
    """
    Folder containing all XTB-related output files for postprocessing.

    XTB calculations generate multiple output files in a single directory.
    This class provides methods to locate and access all these files.

    Typical XTB calculation folder structure:
        xtb_calculation/
        ├─ *.out            → main XTB output file (energy, frequencies, thermodynamics)
        ├─ xtbopt.log       → optimization trajectory log file (XYZ format)
        ├─ charges          → atomic partial charges
        ├─ energy           → total electronic energy
        ├─ *.engrad         → energy, gradient, and coordinates
        ├─ g98.out          → Gaussian-style vibrational analysis output
        ├─ gradient         → nuclear gradients (forces)
        ├─ hessian          → cartesian Hessian matrix
        ├─ vibspectrum      → vibrational frequencies and IR intensities
        ├─ wbo              → Wiberg bond orders
        ├─ xtbopt.*         → optimized geometry (XYZ, SDF, Turbomole coord, PDB, VASP POSCAR,
        │                     DFTB+ gen or Gaussian External format)
        ├─ xtbtopo.mol      → molecular topology and bonding information
        └─ ...              → other auxiliary files
    """

    PARSEABLE_GEOMETRY_EXTENSIONS = (".xyz", ".sdf")
    UNSUPPORTED_GEOMETRY_EXTENSIONS = (
        ".coord",
        ".pdb",
        ".poscar",
        ".gen",
        ".EIn",
    )
    # Files that are commonly generated by xTB calculations
    # Used for stronger validation of xTB calculation directories
    XTB_DIRECTORY_MARKERS = (
        "xtbrestart",
        "charges",
        "xtbtopo.mol",
        "wbo",
    )

    @property
    def is_xtb_calculation_directory(self):
        """
        Check if this folder is a valid xTB calculation directory.

        Uses a two-level validation:
        1. Must contain at least one xTB output file (*.out with xTB keywords)
        2. Must contain at least one common xTB auxiliary file (xtbrestart,
           charges, xtbtopo.mol, or wbo)

        Returns:
            bool: True if this is a valid xTB calculation directory.
        """
        # First check: must have at least one xTB output file
        if not self.is_program_calculation_directory(program="xtb"):
            return False
        # Second check: must have at least one common auxiliary file
        for filename in self.XTB_DIRECTORY_MARKERS:
            filepath = os.path.join(self.folder, filename)
            if os.path.exists(filepath):
                return True
        logger.debug(
            f"Directory {self.folder} has xTB output file but lacks common "
            f"auxiliary files ({', '.join(self.XTB_DIRECTORY_MARKERS)}). "
            f"Not considered a valid xTB calculation directory."
        )
        return False

    def _xtb_out(self):
        """Return the path to the main XTB output file."""
        xtbout = self.get_all_output_files_in_current_folder_by_program(
            program="xtb"
        )
        return xtbout[0] if xtbout else None

    def _xtbopt_log(self):
        """Return the path to optimization trajectory log file."""
        xtbopt_log = os.path.join(self.folder, "xtbopt.log")
        return xtbopt_log if os.path.exists(xtbopt_log) else None

    def _charges(self):
        """Return the path to charge file."""
        charge_file = os.path.join(self.folder, "charges")
        return charge_file if os.path.exists(charge_file) else None

    def _energy(self):
        """Return the path to energy file."""
        energy = os.path.join(self.folder, "energy")
        return energy if os.path.exists(energy) else None

    def _engrad(self):
        """Return the path to engrad file."""
        engrad = self.get_all_files_in_current_folder_by_suffix(".engrad")
        return engrad[0] if engrad else None

    def _g98_out(self):
        """Return the path to the GAUSSIAN-format vibrational frequencies file."""
        g98_out = os.path.join(self.folder, "g98.out")
        return g98_out if os.path.exists(g98_out) else None

    def _gradient(self):
        """Return the path to gradient file."""
        gradient = os.path.join(self.folder, "gradient")
        return gradient if os.path.exists(gradient) else None

    def _hessian(self):
        """Return the path to hessian file."""
        hessian = os.path.join(self.folder, "hessian")
        return hessian if os.path.exists(hessian) else None

    def _vibspectrum(self):
        """Return the path to vibrational spectrum file."""
        vibspectrum = os.path.join(self.folder, "vibspectrum")
        return vibspectrum if os.path.exists(vibspectrum) else None

    def _wbo(self):
        """Return the path to wiberg bond order file."""
        wbo = os.path.join(self.folder, "wbo")
        return wbo if os.path.exists(wbo) else None

    def _input_geometry(self):
        """Return the path to input geometry file used in the XTB calculation."""
        # Try parseable formats first
        for ext in self.PARSEABLE_GEOMETRY_EXTENSIONS:
            geometry_files = self.get_all_files_in_current_folder_by_suffix(
                ext
            )
            for filepath in geometry_files:
                basename = os.path.basename(filepath)
                if not basename.startswith("xtbopt"):
                    logger.debug(f"Found input geometry file: {filepath}")
                    return filepath
        # Check if unsupported format exists
        for ext in self.UNSUPPORTED_GEOMETRY_EXTENSIONS:
            geometry_files = self.get_all_files_in_current_folder_by_suffix(
                ext
            )
            for filepath in geometry_files:
                basename = os.path.basename(filepath)
                if not basename.startswith("xtbopt"):
                    logger.warning(
                        f"Found input geometry file {filepath}, but format {ext} "
                        "is not yet supported by chemsmart."
                    )
                    return filepath
        # No input geometry file found
        return None

    def _xtbopt_geometry(self):
        """
        Return the path to optimized geometry file (xtbopt.*).

        XTB outputs the optimized geometry in the same format as the input.
        This method returns a parseable xtbopt.* file if available, otherwise
        falls back to an unsupported format with a warning.

        Search priority (parseable formats only):
            1. xtbopt.xyz     → XYZ format (supported)
            2. xtbopt.sdf     → SDF format (supported)

        Unsupported formats (will show warning):
            - xtbopt.coord   → Turbomole coord format
            - xtbopt.pdb     → PDB format
            - xtbopt.poscar  → VASP POSCAR format
            - xtbopt.gen     → DFTB+ gen format
            - xtbopt.EIn     → Gaussian External format

        Returns:
            str | None: Path to optimized geometry file, or None if
                        no xtbopt.* file exists
        """
        # Try parseable formats first
        for ext in self.PARSEABLE_GEOMETRY_EXTENSIONS:
            filepath = os.path.join(self.folder, f"xtbopt{ext}")
            if os.path.exists(filepath):
                logger.debug(f"Found optimized geometry file: {filepath}")
                return filepath
        # Check if unsupported format exists
        for ext in self.UNSUPPORTED_GEOMETRY_EXTENSIONS:
            filepath = os.path.join(self.folder, f"xtbopt{ext}")
            if os.path.exists(filepath):
                logger.warning(
                    f"Found optimized geometry file {filepath}, but format {ext} "
                    "is not yet supported by chemsmart."
                )
                return filepath
        # No xtbopt.* file found
        return None

    def _xtbtopo_mol(self):
        """Return the path to molecular topology file."""
        xtbtopo_mol = os.path.join(self.folder, "xtbtopo.mol")
        return xtbtopo_mol if os.path.exists(xtbtopo_mol) else None
