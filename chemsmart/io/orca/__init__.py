class ORCARefs:
    ORCA_BLOCKS = [
        "autoci",  # Controls autogenerated correlation calculations
        "basis",  # Basis sets are specified
        "casscf",  # Control of CASSCF/NEVPT2 and DMRG calculations
        "cipsi",  # Control of Iterative-Configuration Expansion Configuration Interaction calculation
        "cis",  # Control of CIS and TD-DFT calculations (synonym is TDDFT) Cim Control of Cluster
        # In Molecules calculations
        "coords",  # Input of atomic coordinates
        "cpcm",  # Control of the Conductor-like Polarizable Continuum Model
        "Elprop",  # Control of electric property calculations
        "eprnmr",  # Control of SCF level EPR and NMR calculations
        "freq",  # Control of frequency calculations
        "geom",  # Control of geometry optimization
        "ice",  # iterative configuration expansion (ICE)
        # The goal of the ICE-CI is to provide compact wavefunction(s) (e.g. one or several states) close to
        # the full-CI limit at a small fraction of the computational cost. However, ICE-CI itself is not designed
        # to deal with hundreds of atoms or thousands of basis functions.
        "loc",  # Localization of orbitals
        "md",  # Control of molecular dynamics simulation
        "mdci",  # Controls single reference correlation methods
        "method",  # Here a computation method is specified
        "mp2",  # Controls the details of the MP2 calculation
        "mrci",  # Control of MRCI calculations
        "mrcc",  # Control of multi-reference CC calculations
        "numgrad",  # Control of numerical gradients
        "nbo",  # Controls NBO analysis with GENNBO
        "output",  # Control of output
        "pal",  # Control of parallel jobs
        "paras",  # Input of semi-empirical parameters
        "rel",  # Control of relativistic options
        "plots",  # Control of plot generation
        "rocis",  # Control of restricted-open-shell CIS
        "rr",  # Control of resonance Raman and absorption/fluorescence band-shape calculations
        "scf",  # Control of the SCF procedure
        "vpt2",  # Control of the anharmonic frequency calculations
    ]

    ORCA_AB_INITIO = [
        "HF",
        "RHF",
        "UHF",
        "CCSD(T)",
        "DLPNO-CCSD",
        "DLPNO-CCSD(T)",
    ]

    ORCA_FUNCTIONALS = [
        ## % method
        # Choices for "Functional". If no reference is given, look further below for the references for individual
        # exchange and correlation parts
        ## Functional
        # ***************************************
        # Local functionals
        # ***************************************
        "HFS",  # Hartree-Fock Slater (Slater exchange only)
        "XAlpha",  # The famous old Slater Xa theory
        "LSD",  # Local spin density (VWN-5A form)
        "VWN5",  # Local spin density (VWN-5)
        "VWN3",  # Local spin density (VWN-3)
        "PWLDA",  # Local spin density (PW-LDA)
        # ***************************************
        # "Pure" GGA  functionals
        # ***************************************
        "BNULL",  # Becke '88 exchange, no corr.
        "BVWN",  # Becke '88 exchange, VWN-5 corr.
        "BP",  # Becke '88 X-Perdew 86 correlation
        "BP86",  # Becke '88 X-Perdew 86 correlation
        "PW91",  # Perdew-Wang GGA-II '91 func.
        "mPWPW",  # Modified PW with PW correlation
        "mPWLYP",  # same with LYP correlation
        "BLYP",  # Becke X with LYP correlation
        "GP",  # Gill '96 X, Perdew '86 corr.
        "GLYP",  # Gill '96 X with LYP correlation
        "PBE",  # Perdew-Burke-Ernzerhof
        "revPBE",  # Revised PBE (exchange scaling) [296]
        "RPBE",  # Revised PBE (functional form of X) [297]
        "PWP",  # PW91 exchange + P86 correlation
        "OLYP",  # the optimized exchange and LYP
        "OPBE",  # the optimized exchange and PBE
        "XLYP",  # the Xu/Goddard exchange and LYP
        "B97-D",  # Grimme's GGA including D2 dispersion correction
        "B97-D3",  # Grimme's GGA including D3 dispersion correction
        "PW86PBE",  # as used for vdw-DF and related [298] [299] [300]
        "RPW86PBE",  # revised version of the exchange functional [301]
        # ***************************************
        # Meta GGA  functionals
        # ***************************************
        "M06L",  # Truhlar's semi-local functional [302]
        "TPSS",  # the TPSS functional
        "revTPSS",  # revised TPSS [303] [304]
        "B97M-V",  # Head-Gordon's meta-GGA functional with VV10 correction [305]
        "B97M-D3BJ",  # Head-Gordon's DF with D3BJ correction  [139]
        "B97M-D4",  # Head Gordon's DF with D4 correction [140]
        "SCANfunc",  # Perdew's SCAN functional [306]
        "RSCAN",  # regularized SCAN functional [307]
        "R2SCAN",  # regularized and restored SCAN functional [308]
        # ***************************************
        # Hybrid  functionals
        # ***************************************
        "B1LYP",  # One parameter Hybrid of BLYP
        "B3LYP",  # Three parameter Hybrid of BLYP [309]
        "B1P",  # Analogous with Perdew correlation
        "B3P",  # Analogous with Perdew correlation
        "G1LYP",  # 1 par. analog with Gill 96 X
        "G3LYP",  # 3 par. analog with Gill 96 X
        "G1P",  # similar with P correlation
        "G3P",  # similar with P correlation
        "PBE0",  # 1 parameter version of PBE [310]
        "PWP1",  # 1 parameter version of PWP (analogous to PBE0)
        "M06",  # Truhlar's 2006 low-HF hybrid  [311]
        "M062X",  # Truhlar's 2006 high-HF hybrid [311]
        "M06-2X",  # Truhlar's 2006 high-HF hybrid [311]
        "mPW1PW",  # 1 parameter version of mPWPW (analogous to PBE0)
        "mPW1LYP",  # 2 parameter version of mPWLYP (analogous to PBE0)
        "PW91_0",  # 1 parameter version of PW91 (analogous to PBE0)
        "O3LYP",  # 3 parameter version of OLYP [312]
        "X3LYP",  # 3 parameter version of XLYP [313]
        "PW6B95",  # Hybrid functional by Truhlar [314]
        "B97",  # Becke's original hybrid
        "BHANDHLYP",  # Half-and-half Becke hybrid functional [315]
        # ***************************************
        # Range-Separated Hybrid  functionals
        # ***************************************
        "wB97",  # Head-Gordon's fully variable DF [135]
        "wB97X",  # Head-Gordon's DF with minimal Fock exchange [135]
        "wB97X-D3",  # Chai's refit incl. D3 correction [136]
        "wB97X-V",  # Head-Gordon's DF with nonlocal correlation [137]
        "wB97X-D3BJ",  # Head-Gordon's DF with D3BJ correction [139]
        "CAM-B3LYP",  # Handy's fit [132]
        "LC-BLYP",  # Hirao's original application [133]
        "LC-PBE",  # Hirao's PBE-based range-separated hybrid [131]
        # ***************************************
        # Meta Hybrid  functionals
        # ***************************************
        "TPSSh",  # hybrid version of TPSS with 10% HF exchange
        "TPSS0",  # hybrid version of TPSS with 25% HF exchange
        # ***************************************
        # Double-Hybrid  functionals (mix in MP2)
        # ***************************************
        "B2PLYP",  # Grimme's 2006 double-hybrid [115]
        "mPW2PLYP",  # Schwabe/Grimme improved double-hybrid [116]
        "B2GP-PLYP",  # Martin's refit of B2PLYP [118]
        "B2K-PLYP",  # Martin's refit of B2PLYP [118]
        "B2T-PLYP",  # Martin's refit of B2PLYP [118]
        "PWPB95",  # Goerigk and Grimme's double hybrid with spin-opposite'scaling[119]
        "PBE-QIDH",  # Adamo's PBE-based double hybrid [316]
        "PBE0-DH",  # Adamo's PBE-based double hybrid [317]
        "SCS/SOS-B2PLYP21",  # spin-opposite scaled version of B2PLYP optimized for excited states by Casanova-P ́aez
        # and Goerigk (SCS fit gave SOS version; SOS only applies to the CIS(D) component) [206]
        "SCS-PBE-QIDH",  # spin-component scaled version of PBE-QIDH optimized for excited states by Casanova-P ́aez
        # and Goerigk (SCS only applies to the CIS(D) component) [206]
        "SOS-PBE-QIDH",  # spin-opposite scaled version of PBE-QIDH optimized for excited states by Casanova-P ́aez
        # and Goerigk (SOS only applies to the CIS(D) component) [206]
        "SCS-B2GP-PLYP21",  # spin-component scaled version of B2GP-PLYP optimized for excited states by Casanova-P ́aez
        # and Goerigk (SCS only applies to the CIS(D) component) [206]
        "SOS-B2GP-PLYP21",  # spin-opposite scaled version of B2GP-PLYP optimized for excited states by Casanova-P ́aez
        # and Goerigk (SOS only applies to the CIS(D) component) [206]
        # ***************************************
        # Range-Separated Double-Hybrid functionals
        # ***************************************
        "wB2PLYP",  # Casanova-P'aez and Goerigk's range-separated DHDF for excitation energies[141]
        "wB2GP-PLYP",  # Casanova-P'aez and Goerigk's range-separated DHDF for excitation energies[141]
        "wB97X-2",  # Chai and Head-Gordon's range-separated GGA DHDF with spin - component scaling[318]
        "RSX-QIDH",  # range-separated DHDF by Adamo and co-workers [319]
        "RSX-0DH",  # range-separated DHDF by Adamo and co-workers [320]
        "wPBEPP86",  # Casanova-P ́aez and Goerigk's range-separated DHDF optimized for excitation energies [206]
        "wPBEPP86",  # Casanova-P ́aez and Goerigk's range-separated DHDF optimized for excitation energies [206]
        "SCS/SOS-wB2PLYP",  # spin-opposite scaled DHDF optimized for excitation energies by Casanova-P ́aez
        # and Goerigk (SCS fit gave SOS version; SOS only applies to the CIS(D) component)[206]
        "SCS-wB2GP-PLYP",  # spin-component scaled DHDF optimized for excitation energies by Casanova-P ́aez
        # and Goerigk (SCS only applies to the CIS(D) component)[206]
        "SOS-wB2GP-PLYP",  # spin-opposite scaled DHDF optimized for excitation energies by Casanova-P ́aez
        # and Goerigk (SOS only applies to the CIS(D) component) [206]
        "SCS-RSX-QIDH ",  # spin-component scaled DHDF optimized for excitation energies by Casanova-P ́aez
        # and Goerigk (SCS only applies to the CIS(D) component) [206]
        "SOS-RSX-QIDH",  # spin-opposite scaled DHDF optimized for excitation energies by Casanova-P ́aez
        # and Goerigk (SOS only applies to the CIS(D) component) [206]
        "SCS-wB88PP86",  # spin-component scaled DHDF optimized for excitation energies by Casanova-P ́aez
        # and Goerigk (SCS only applies to the CIS(D) component) [206]
        "SOS-wB88PP86",  # spin-opposite scaled DHDF optimized for excitation energies by Casanova-P ́aez
        # and Goerigk (SOS only applies to the CIS(D) component) [206]
        "SCS-wPBEPP86",  # spin-component scaled DHDF optimized for excitation energies by Casanova-P ́aez
        # and Goerigk (SCS only applies to the CIS(D) component) [206]
        "SOS-wPBEPP86",  # spin-opposite scaled DHDF optimized for excitation energies by Casanova-P ́aez
        # and Goerigk (SOS only applies to the CIS(D) component) [206]
        ## end
    ]

    ORCA_BASIS_POLARIZATIONS = [
        "*",
        "(d)",
        "**",
        "(d,p)",
        "(2d)",
        "(2df)",
        "(2d,p)",
        "(2d,2p)",
        "(2df,2p)",  #  2 sets of d functions and one set of f functions on heavy atoms,
        # and supplemented by 2 sets of p functions on hydrogens.
        "(2df,2pd)",
        "(3df)",  # for the 6-311G basis set
        "(3df,3pd)",  # for the 6-311G basis set
    ]

    ORCA_BASIS_DIFFUSIONS = [
        "+",  # before G.  Include diffuse functions on all atoms except H (e.g. 6-31+G)
        "++",  # before G. Include diffuse functions on all atoms. Works only when H polarization is already included,
        # e.g. 6-31++G(d,p)
    ]

    ORCA_BASIS_FOR_POLARIZATION_AND_DIFFUSSION = [
        "6-31G",  # Pople 6-31G and its modifications (H-Zn)
        "6-311G",  # Pople 6-311G and its modifications (H-Br)
    ]

    ORCA_STANDARD_BASIS_SETS_POPLE = [
        # ***************************************
        # Pople - style basis sets
        # ***************************************
        "STO-3G",  # Minimal basis set (H-I)
        "3-21G",  # Pople 3-21G (H-Cs)
        "3-21GSP",  # Buenker 3-21GSP (H-Ar)
        "4-22GSP",  # Buenker 4-22GSP (H-Ar)
        "6-31G",  # Pople 6-31G and its modifications (H-Zn)
        "m6-31G",  # Modified 6-31G for 3d transition metals (Sc-Cu)
        "6-311G",  # Pople 6-311G and its modifications (H-Br)
    ]

    ORCA_STANDARD_BASIS_SETS_KARLSRUHE_DEF2 = [
        # ***************************************
        # The def2 basis sets of the Karlsruhe group
        # These basis sets are all-electron for elements H-Kr,
        # and automatically load Stuttgart-Dresden effective core potentials for elements Rb-Rn.
        # ***************************************
        "def2-SVP",  # Valence double-zeta basis set with “new” polarization functions.
        "def2-SV(P)",  # The above with slightly reduced polarization.
        "def2-TZVP",  # Valence triple-zeta basis set with “new” polarization functions.
        # Note that this is quite similar to the older (“def ”) TZVPP for the main group elements and TZVP for hydrogen.
        "def2-TZVP(-f)",  # TZVP with f polarization removed from main group elements.
        "def2-TZVPP",  # TZVPP basis set with “new” polarization functions.
        "def2-QZVP",  # Polarized quadruple-zeta basis.
        "def2-QZVPP",  # Accurate doubly polarized quadruple-zeta basis.
    ]

    ORCA_STANDARD_BASIS_SETS_KARLSRUHE_DEF = [
        # ***************************************
        # Older (“def”) Ahlrichs basis sets
        # All-electron basis sets for elements H-Kr.
        # ***************************************
        "SV",  # Valence double - zeta basis set.
        "SV(P)",  # Valence double - zeta with polarization only on heavy elements.
        "SVP",  # Polarized valence double-zeta basis set.
        "TZV",  # Valence triple-zeta basis set.
        "TZV(P)",  # Valence triple-zeta with polarization on heavy elements.
        "TZVP",  # Polarized valence triple-zeta basis set.
        "TZVPP",  # Doubly polarized triple-zeta basis set.
        "QZVP",  # Polarized valence quadruple-zeta basis set.
        "QZVPP",  # Doubly polarized quadruple-zeta basis set.
    ]

    ORCA_JENSEN_BASIS_SETS = [
        "pc-n",  # (n=0, 1, 2, 3, 4) “Polarization - consistent” generally contracted basis sets(H-Kr) of up to
        # quintuple-zeta quality, optimized for SCF calculations
        "aug-pc-n",  # As above, augmented by diffuse functions
        "pcseg-n",  # Segmented PC basis sets (H-Kr), DFT-optimized
        "aug-pcseg-n",  # As above, augmented by diffuse functions
        "pcSseg-n",  # Segmented contracted basis sets (H-Kr) optimized for nuclear magnetic shielding
        "aug-pcSseg-n",  # As above, augmented by diffuse functions
        "pcJ-n",  # Segmented contracted basis sets (H-Ar) optimized for spin-spin coupling constants
        "aug-pcJ-n",  # As above, augmented by diffuse functions
    ]

    ORCA_SAPPORO_BASIS_SETS = [
        "Sapporo-nZP-2012",  # (n=D, T, Q) All-electron generally contracted non - relativistic basis sets(H-Xe)
        "Sapporo-DKH3-nZP-2012",  # (n=D, T, Q) All-electron basis sets optimized for the DKH3 Hamiltonian and
        # finite nucleus (K-Rn)
    ]

    ORCA_CORRELATION_CONSISTENT_BASIS_SETS = [
        "cc-pVnZ",  # (n=D, T, Q, 5, 6) Dunning correlation-consistent polarized n-zeta
        "aug-cc-pVnZ",  # (n=D, T, Q, 5, 6) Augmented with diffuse functions
        "cc-pCVnZ",  # (n=D, T, Q, 5, 6) Core - polarized basis sets
        "aug-cc-pCVnZ",  # (n=D, T, Q, 5, 6) as above, augmented with diffuse functions
        "cc-pwCVnZ",  # (n = D, T, Q, 5) Core-polarized with weighted core functions
        "aug-cc-pwCVnZ",  # (n = D, T, Q, 5) as above, augmented with diffuse functions
        "cc-pVn(+d)Z",  # (n = D, T, Q, 5) with tight d functions
    ]

    ORCA_PARTIALLY_AUGMENTED_CC_BASIS_SETS = [
        "apr-cc-pV(Q+d)Z",  # Augmented with sp diffuse functions on Li-Ca
        "may-cc-pV(n+d)Z",  # (n = T, Q): sp(T), spd(Q) on Li-Ca
        "jun-cc-pV(n+d)Z",  # (n=D, T, Q): sp(D), spd(T), spdf(Q) on Li-Ca
        "jul-cc-pV(n+d)Z",  # (n=D, T, Q): spd(D), spdf(T), spdfg(Q) on Li-Ca
        "maug-cc-pV(n+d)Z",  # same as jun-, may-, and apr- for n = D, T, and Q, respectively
    ]

    ORCA_F12_F12_CABS_BASIS_SETS = [
        "cc-pVnZ-F12",  # (n=D, T, Q) Special orbital basis sets for F12 calculations(larger than the regular
        # # D, T, Q-zeta basis sets!)
        "cc-pCVnZ-F12",  # (n = D, T, Q) with core polarization functions
        "cc-pVnZ-PP-F12",  # (n = D, T, Q) ECP-based versions
        "cc-pVnZ-F12-CABS",  # (n = D, T, Q) Near-complete auxiliary basis sets for F12 calculations
        "cc-pVnZ-F12-OptRI",  # (n = D, T, Q) identical to the cc-pVnZ-F12-CABS basis above
        "cc-pCVnZ-F12-OptRI",  #  (n = D, T, Q)
        "cc-pVnZ-PP-F12-OptRI",  #  (n = D, T, Q)
        "aug-cc-pVnZ-PP-OptRI",  # (n = D, T, Q, 5)
        "aug-cc-pwCVnZ-PP-OptRI",  #  (n = D, T, Q, 5)
    ]

    ORCA_ANO_BASIS_SETS = [
        "ANO-pVnZ",  # (n=D, T, Q, 5, 6). Our newly contracted ANO basis sets on the basis of the cc-pV6Z (or pc-4 where
        # missing) primitives.These are very accurate basis sets that are significantly better than the cc-pVnZ
        # counterparts for the same number of basis functions (but much larger number of primitives of course).
        "saug-ANO-pVnZ",  # (n = D, T, Q, 5) augmentation with a single set of sp functions.Greatly enhances the
        # accuracy of the SCF energies but not for correlation energies.
        "aug-ANO-pVnZ",  # (n = D, T, Q, 5) full augmentation with spd, spdf, spdfg set of polarization functions.
        # Almost as expensive as the next higher basis set. In fact, aug-ANO-pVnZ = ANO-pV(n + 1)Z with the highest
        # angular momentum polarization function deleted.
        # Relativistic contracted ANO-RCC basis sets
        "ANO-RCC-FULL",  # The complete ANO-RCC basis sets (H-Cm). Some default contractions are provided for
        # convenience with the keywords:
        "ANO-RCC-nZP",  # (n = D, T, Q)
    ]

    ORCA_MISC_SPECIALIZED_BASIS_SETS = [
        "D95",  # Dunning's double-zeta basis set(H-Cl).
        "D95p",  # Polarized version of D95.
        "MINI",  # Huzinaga's minimal basis set.
        "MINIS",  # Scaled version of the MINI.
        "MIDI",  # Huzinaga's valence double-zeta basis set.
        "MINIX",  # Combination of small basis sets by Grimme.
        "Wachters+f",  # First-row transition metal basis set(Sc-Cu).
        "Partridge-n",  # (n = 1, 2, 3, 4) Uncontracted basis sets by Partridge.
        "LANL2DZ",  # Los Alamos valence double-zeta with Hay-Wadt ECPs.
        "LANL2TZ",  # Triple-zeta version.
        "LANL2TZ(f)",  # Triple-zeta plus polarization.
        "LANL08",  # Uncontracted basis set.
        "LANL08(f)",  # Uncontracted basis set + polarization.
        "EPR-II",  # Barone's basis set (H, B-F) for EPR calculations (double-zeta).
        "EPR-III",  # Barone's basis set for EPR calculations (triple-zeta).
        "IGLO-II",  # Kutzelnigg's basis set (H, B-F, Al-Cl) for NMR and EPR calculations.
        "IGLO-III",  # Larger version of the above.
        "aug-cc-pVTZ-J",  # Sauer's basis set for accurate hyperfine coupling constants.
    ]

    ORCA_EXTRAPOLATION_BASIS = [
        "Extrapolate(n/m,bas)",  # Extrapolation of the basis set family “bas” (bas=cc,aug-cc, cc-core, ano, saug-ano,
        # aug-ano, def2; if omitted “cc-pVnZ” is used) for cardinal numbers n,m (n<m=2,3,4,5),
        # e.g. Extrapolate(2/3,cc) extrapolates the SCF, MP2 and MDCI energies to the basis set limit.
        # “core” refers to basis sets with core correlation function. frozen core approximation turned off (default).
        # This setting can be overridden in the “methods” block if one just wants to use the basis set with core
        # correlation functions (steep primitives) but without unfreezing the core electrons.
        "Extrapolate(n,bas)",  # Calculate the first n-energies for member of the basis set family basis,
        # e.g. Extrapolate(3) is doing calculations with cc-pVDZ, cc-pVTZ and cc-pVQZ.
        "ExtrapolateEP2(n/m,bas,[method,method-details])",  # Similar: performs SCF, MP2 and MDCI calculations.
        # The higher basis set can only be done with DLPNO-CCSD(T) or MP2 methods and then used to extrapolate the MDCI
        # calculation to the basis set limit. E.g., ExtrapolateEP2(2/3,ANO,MP2); ExtrapolateEP2(2/3,cc,DLPNO-CCSD(T))
        "ExtrapolateEP3(bas,[method,method-details])",  # Similar to EP2: for high basis set one cardinal number higher.
        # method is optional and can be either MP2 or DLPNO-CCSD(T), the latter being the default.
        # In case method is DLPNO-CCSD(T), in method-details option one can ask for LoosePNO, NormalPNO or TightPNO.
    ]

    ORCA_AUXILIARY_COULOMB_BASIS_SETS = [
        "Def2/J",  # Weigend's “universal” Coulomb fitting basis that is suitable for all def2 type basis sets.
        # Assumes the use of ECPs beyond Kr (do not use with DKH / ZORA).
        "SARC/J",  # General-purpose Coulomb fitting basis set for all-electron calculations.
        # Consists of the decontracted def2/J up to Kr and of our own auxiliary basis sets for the rest of the periodic
        # table.Appropriate for use in DKH or ZORA calculations with the recontracted versions of the all-electron
        # def2 basis sets (up to Kr) and the SARC basis sets for the heavier elements.
        "x2c/J",  # Weigend's Coulomb fitting basis for the all-electron x2c-XVPall basis sets.
    ]

    ORCA_AUXILIARY_COULOMB_EXCHANGE_BASIS_SETS = [
        "Def2/JK",  # Coulomb + Exchange fitting for all def2 basis sets
        "Def2/JKsmall",  # reduced version of the above
        "cc-pVnZ/JK",  # (n = T, Q, 5) for the respective cc-pVnZ orbital basis
        "aug-cc-pVnZ/JK",  # (n = T, Q, 5) for the respective aug-cc-pVnZ orbital basis
    ]

    ORCA_AUXILIARY_CC_BASIS_SETS = [
        "Def2-SVP/C",  # Correlation fitting for the def2-SVP orbital basis
        "Def2-TZVP/C",  # for the def2-TZVP orbital basis
        "Def2-TZVPP/C",  # for the def2-TZVPP orbital basis
        "Def2-QZVPP/C",  # for the def2-QZVPP orbital basis
        "Def2-SVPD/C",  # for the def2-SVPD orbital basis
        "Def2-TZVPD/C",  # for the def2-TZVPD orbital basis
        "Def2-TZVPPD/C",  # for the def2-TZVPPD orbital basis
        "Def2-QZVPPD/C",  # for the def2-QZVPPD orbital basis
        "cc-pVnZ/C",  # (n = D, T, Q, 5, 6) for the respective cc-pVnZ orbital basis
        "aug-cc-pVnZ/C",  # (n = D, T, Q, 5, 6) for the respective aug-cc-pVnZ orbital basis
        "cc-pwCVnZ/C",  # (n = D, T, Q, 5) for the respective cc-pwCVnZ orbital basis
        "aug-cc-pwCVnZ/C",  # (n = D, T, Q, 5) for the respective aug-cc-pwCVnZ orbital basis
        "cc-pVnZ-PP/C",  # (n = D, T, Q) for the respective cc-pVnZ-PP orbital basis
        "aug-cc-pVnZ-PP/C",  # (n = D, T, Q) for the respective aug-cc-pVnZ-PP orbital basis
        "cc-pwCVnZ-PP/C",  # (n = D, T, Q) for the respective cc-pwCVnZ-PP orbital basis
        "aug-cc-pwCVnZ-PP/C",  # (n = D, T, Q) for the respective aug-cc-pwCVnZ-PP orbital basis
        "cc-pVnZ-F12-MP2fit",  # (n = D, T, Q) for the respective cc-pVnZ-F12 orbital basis
        "cc-pCVnZ-F12-MP2fit",  # (n = D, T, Q) for the respective cc-pCVnZ-F12 orbital basis
        "cc-pVnZ-PP-F12-MP2fit",  # (n = D, T, Q) for the respective cc-pVnZ-PP-F12 orbital basis
    ]

    ORCA_AUXILIARY_AUTOAUX = [
        "AutoAux",  # Automatic construction of a general purpose auxiliary basis for simultaneously fitting
        # Coulomb, exchange and correlation calculations.
    ]

    ORCA_ECPS = [
        "def2-ECP",  # Karlsruhe basis sets: def2-SVP, def2-TZVP, etc. def2-SVPD, def2-TZVPD, etc.
        # ma-def2-SVP, ma-def2-TZVP, etc.
        "SK-MCDHF-RSC",  # Correlation-consistent basis sets: cc-pVnZ-PP, aug-cc-pVnZ-PP, cc-pCVnZ-PP, aug-cc-pCVnZ-PP,
        # cc-pwCVnZ-PP, aug-cc-pwCVnZ-PP (n=D,T,Q,5) cc-pVnZ-PP (n = D, T, Q)
        "HayWadt",  # LANL-type basis sets: LANL2DZ, LANL2TZ, LANL2TZ(f), LANL08, LANL08(f)
        "dhf-ECP",  # dhf-type Karlsruhe basis sets: dhf-SVP, dhf-TZVP, etc.
        # Legacy definitions
        "def2-SD",
        "def-SD",
        "SDD",
        "LANL1",
        "LANL2",
    ]

    ORCA_JOB_TYPES = [
        "opt",  # geometry optimisation
        "freq"  # vibrational frequency
        "engrad",  # energy + gradient
        "md",  # molecular dynamics
    ]

    ORCA_SOLVENT_MODELS = [
        "cpcm",  # conductor-like polarizable continuum model
        "smd",  # solvation model based on density
    ]

    ORCA_SOLVENT_IDS = [
        "1,1,1-TRICHLOROETHANE",
        "1,1,2-TRICHLOROETHANE",
        "1,2,4-TRIMETHYLBENZENE",
        "1,2-DIBROMOETHANE",
        "1,2-DICHLOROETHANE",
        "1,2-ETHANEDIOL",
        "1,4-DIOXANE",
        "1-BROMO-2-METHYLPROPANE",
        "1-BROMOOCTANE",
        "1-BROMOPENTANE",
        "1-BROMOPROPANE",
        "1-BUTANOL",
        "1-CHLOROHEXANE",
        "1-CHLOROPENTANE",
        "1-CHLOROPROPANE",
        "1-DECANOL",
        "1-FLUOROOCTANE",
        "1-HEPTANOL",
        "1-HEXANOL",
        "1-HEXENE",
        "1-HEXYNE",
        "1-IODOBUTANE",
        "1-IODOHEXADECANE",
        "1-IODOPENTANE",
        "1-IODOPROPANE",
        "1-NITROPROPANE",
        "1-NONANOL",
        "1-OCTANOL",
        "1-PENTANOL",
        "1-PENTENE",
        "1-PROPANOL",
        "2,2,2-TRIFLUOROETHANOL",
        "2,2,4-TRIMETHYLPENTANE",
        "2,4-DIMETHYLPENTANE",
        "2,4-DIMETHYLPYRIDINE",
        "2,6-DIMETHYLPYRIDINE",
        "2-BROMOPROPANE",
        "2-BUTANOL",
        "2-CHLOROBUTANE",
        "2-HEPTANONE",
        "2-HEXANONE",
        "2-METHOXYETHANOL",
        "2-METHYL-1-PROPANOL",
        "2-METHYL-2-PROPANOL",
        "2-METHYLPENTANE",
        "2-METHYLPYRIDINE",
        "2-NITROPROPANE",
        "2-OCTANONE",
        "2-PENTANONE",
        "2-PROPANOL",
        "2-PROPEN-1-OL",
        "E-2-PENTENE",
        "3-METHYLPYRIDINE",
        "3-PENTANONE",
        "4-HEPTANONE",
        "4-METHYL-2-PENTANONE",
        "4-METHYLPYRIDINE",
        "5-NONANONE",
        "ACETONE",
        "ACETONITRILE",
        "ACETOPHENONE",
        "ANILINE",
        "ANISOLE",
        "BENZALDEHYDE",
        "BENZENE",
        "BENZONITRILE",
        "BENZYL ALCOHOL",
        "BROMOBENZENE",
        "BROMOETHANE",
        "BROMOFORM",
        "BUTANAL",
        "BUTANOIC ACID",
        "BUTANONE",
        "BUTANONITRILE",
        "BUTYL ETHANOATE",
        "BUTYLAMINE",
        "N-BUTYLBENZENE",
        "SEC-BUTYLBENZENE",
        "TERT-BUTYLBENZENE",
        "CARBON DISULFIDE",
        "CARBON TETRACHLORIDE",
        "CHLOROBENZENE",
        "CHLOROFORM",
        "A-CHLOROTOLUENE",
        "O-CHLOROTOLUENE",
        "M-CRESOL",
        "O-CRESOL",
        "CYCLOHEXANE",
        "CYCLOHEXANONE",
        "N-DECANE",
        "DIBROMOMETHANE",
        "DIBUTYLETHER",
        "O-DICHLOROBENZENE",
        "E-1,2-DICHLOROETHENE",
        "Z-1,2-DICHLOROETHENE",
        "DICHLOROMETHANE",
        "DIETHYL ETHER",
        "DIETHYL SULFIDE",
        "DIETHYLAMINE",
        "DIIODOMETHANE",
        "DIISOPROPYL ETHER",
        "CIS-1,2-DIMETHYLCYCLOHEXANE",
        "DIMETHYL DISULFIDE",
        "N,N-DIMETHYLACETAMIDE",
        "N,N-DIMETHYLFORMAMIDE",
        "DIMETHYLSULFOXIDE",
        "DIPHENYLETHER",
        "DIPROPYLAMINE",
        "N-DODECANE",
        "ETHANETHIOL",
        "ETHANOL",
        "ETHYL ETHANOATE",
        "ETHYL METHANOATE",
        "ETHYL PHENYL ETHER",
        "ETHYLBENZENE",
        "FLUOROBENZENE",
        "FORMAMIDE",
        "FORMIC ACID",
        "N-HEPTANE",
        "N-HEXADECANE",
        "N-HEXANE",
        "HEXANOIC ACID",
        "IODOBENZENE",
        "IODOETHANE",
        "IODOMETHANE",
        "ISOPROPYLBENZENE",
        "P-ISOPROPYLTOLUENE",
        "MESITYLENE",
        "METHANOL",
        "METHYL BENZOATE",
        "METHYL BUTANOATE",
        "METHYL ETHANOATE",
        "METHYL METHANOATE",
        "METHYL PROPANOATE",
        "N-METHYLANILINE",
        "METHYLCYCLOHEXANE",
        "N-METHYLFORMAMIDE",
        "NITROBENZENE",
        "NITROETHANE",
        "NITROMETHANE",
        "O-NITROTOLUENE",
        "N-NONANE",
        "N-OCTANE",
        "N-PENTADECANE",
        "PENTANAL",
        "N-PENTANE",
        "PENTANOIC ACID",
        "PENTYL ETHANOATE",
        "PENTYLAMINE",
        "PERFLUOROBENZENE",
        "PROPANAL",
        "PROPANOIC ACID",
        "PROPANONITRILE",
        "PROPYL ETHANOATE",
        "PROPYLAMINE",
        "PYRIDINE",
        "TETRACHLOROETHENE",
        "TETRAHYDROFURAN",
        "TETRAHYDROTHIOPHENE-S,S-DIOXIDE",
        "TETRALIN",
        "THIOPHENE",
        "THIOPHENOL",
        "TOLUENE",
        "TRANS-DECALIN",
        "TRIBUTYLPHOSPHATE",
        "TRICHLOROETHENE",
        "TRIETHYLAMINE",
        "N-UNDECANE",
        "WATER",
        "XYLENE",
        "M-XYLENE",
        "O-XYLENE",
        "P-XYLENE",
    ]

    ORCA_SOLVENT_IDS_SHORT_NAMES = [
        "DMF",
        "DMSO",
        "THF",
        "MeCN",
        "CCl4",
        "PhNO2",
        "MeNO2",
    ]

    ORCA_SCF_CONVERGENCE_CRITERIA = [
        "sloppy",
        "loose",
        "medium",
        "strong",
        "tight",
        "verytight",
        "extreme",
    ]

    O_DENSITY_OPTIONS = ["none", "unrelaxed", "relaxed"]

    ORCA_SCF_ALGORITHMS = ["direct", "diis", "kdiis"]

    ORCA_DISPERSION_CORRECTIONS = ["d2", "d3zero", "d3bj", "d4"]

    ORCA_QMMM_JOBTYPE = [
        "QMMM",
        "QM/QM2",
        "QM/QM2/MM",
        "MOL-CRYSTAL-QMMM",
        "IONIC-CRYSTAL-QMMM",
    ]

    ORCA_QM2_BUILT_IN_METHODS = [
        "XTB",
        "XTB0",
        "XTB1",
        "HF-3C",
        "PBEH-3C",
        "R2SCAN-3C",
        "PM3",
        "AM1",
    ]

    @property
    def orca_blocks(self):
        return [i.lower() for i in self.ORCA_BLOCKS]

    @property
    def orca_functionals(self):
        return [i.lower() for i in self.ORCA_FUNCTIONALS]

    @property
    def orca_ab_initio(self):
        return [i.lower() for i in self.ORCA_AB_INITIO]

    @property
    def orca_basis_pople(self):
        return [basis.lower() for basis in self.ORCA_STANDARD_BASIS_SETS_POPLE]

    @property
    def orca_basis_with_polarization(self):
        orca_basis_with_polarization = []

        for orca_basis in self.ORCA_BASIS_FOR_POLARIZATION_AND_DIFFUSSION:
            if orca_basis == "6-31G":
                for polarization in self.ORCA_BASIS_POLARIZATIONS:
                    if polarization not in ("(3df)", "(3df,3pd)"):
                        orca_basis_with_polarization.append(
                            f"{orca_basis}{polarization}"
                        )  # noqa: PERF401
            elif orca_basis == "6-311G":  # all possible combinations
                for polarization in self.ORCA_BASIS_POLARIZATIONS:
                    orca_basis_with_polarization.append(
                        f"{orca_basis}{polarization}"
                    )  # noqa: PERF401
        # convert all to lower cases
        return [basis.lower() for basis in orca_basis_with_polarization]

    @property
    def orca_basis_with_polarization_and_diffusion(self):
        orca_basis_with_polarization_and_diffusion = [
            "6-31+G",  # diffusion only, no polarization
            "6-31+G*",
            "6-31+G(d)",
        ]

        for polarization in self.ORCA_BASIS_POLARIZATIONS:
            if (
                "**" in polarization
                or ",p" in polarization
                or ",2p" in polarization
                or ",3p" in polarization
            ):
                orca_basis = f"6-311++G{polarization}"
                orca_basis_with_polarization_and_diffusion.append(orca_basis)

        return [
            basis.lower()
            for basis in orca_basis_with_polarization_and_diffusion
        ]

    @property
    def orca_basis_karlsruhe_def2(self):
        return [
            basis.lower()
            for basis in self.ORCA_STANDARD_BASIS_SETS_KARLSRUHE_DEF2
        ]

    @property
    def orca_basis_karlsruhe_def(self):
        return [
            basis.lower()
            for basis in self.ORCA_STANDARD_BASIS_SETS_KARLSRUHE_DEF
        ]

    @property
    def orca_basis_karlsruhe_minimally_augmented(self):
        """Diffuse def2 basis sets. Minimally augmented def2 basis sets.

        Augmented def2 basis sets by diffuse s and p functions according to Truhlar[1].
        Recommended for general use.
        # ***************************************.
        """
        orca_basis_karlsruhe_minimally_augmented = []
        for basis in self.orca_basis_karlsruhe_def2:
            ma_basis = f"ma-{basis}"
            orca_basis_karlsruhe_minimally_augmented.append(ma_basis)
        return orca_basis_karlsruhe_minimally_augmented

    @property
    def orca_basis_karlsruhe_rappoport_property(self):
        """Rappoport property - optimized diffuse def2 basis sets.

        Augmented def2 basis sets by diffuse functions according to Rappoport et al.[2].
        """
        orca_basis_karlsruhe_rappoport_property = []
        for basis in self.orca_basis_karlsruhe_def2:
            if "(" not in basis:
                property_basis = f"{basis}D"
                orca_basis_karlsruhe_rappoport_property.append(property_basis)
        return orca_basis_karlsruhe_rappoport_property

    @property
    def orca_basis_karlsruhe_Dirac_Fock_ECPs(self):
        """Karlsruhe basis sets with Dirac-Fock ECPs.

        Derived from the def2-XVP ones with small modifications for 5s, 6s,
        4d, and 5d elements and iodine. [3] They are optimized for the revised Dirac-Fock ECPs (dhf-ECP) as opposed to
        the Wood-Boring ones (def2-ECP).
        """
        orca_basis_karlsruhe_Dirac_Fock_ECPs = []
        for basis in self.orca_basis_karlsruhe_def2:
            if "(-f)" not in basis:
                df_ecp_basis = basis.replace("def2", "dhf")
                orca_basis_karlsruhe_Dirac_Fock_ECPs.append(df_ecp_basis)
        return orca_basis_karlsruhe_Dirac_Fock_ECPs

    @property
    def orca_basis_relativistic_DKH_ZORA(self):
        """Relativistically recontracted Karlsruhe basis sets.

        For use in DKH or ZORA calculations we provide adapted versions of the def2 basis sets for the elements H-Kr
        (i.e., for the all-electron def2 basis sets). These basis sets retain the original def2 exponents but have only
        one contracted function per angular momentum (and hence are somewhat larger), with contraction coefficients
        suitable for the respective scalar relativistic Hamiltonian. These basis sets can be called with the prefix
        DKH- or ZORA-, and can be combined with the SARC basis sets for the heavier elements.
        """
        orca_basis_relativistic_DKH_ZORA = []
        for basis in self.orca_basis_karlsruhe_def2:
            dkh_basis = f"DKH-{basis}"
            orca_basis_relativistic_DKH_ZORA.append(dkh_basis)
            zora_basis = f"ZORA-{basis}"
            orca_basis_relativistic_DKH_ZORA.append(zora_basis)
        return orca_basis_relativistic_DKH_ZORA

    @property
    def orca_basis_relativistic_DKH_ZORA_ma(self):
        """Minimally augmented versions."""
        orca_basis_relativistic_DKH_ZORA_ma = []
        for basis in self.orca_basis_relativistic_DKH_ZORA:
            ma_basis = f"ma-{basis}"
            orca_basis_relativistic_DKH_ZORA_ma.append(ma_basis)
        return orca_basis_relativistic_DKH_ZORA_ma

    @property
    def orca_basis_x2c(self):
        """All-electron Karlsruhe basis sets up to Rn for exact two-component methods (X2C)."""
        orca_basis_x2c = []
        for basis in self.orca_basis_karlsruhe_def:
            if basis not in ("SV", "TZV", "TZV(P)"):
                x2c_basis = f"x2c-{basis}all"
                orca_basis_x2c.append(x2c_basis)
        return orca_basis_x2c

    @property
    def orca_basis_x2c_2c(self):
        """The “-2c” variants are intended for two-component calculations including spin-orbit coupling.

        Note that two-component methods are currently not implemented in ORCA.
        """
        orca_basis_x2c_2c = []
        for basis in self.orca_basis_x2c:
            x2c_2c_basis = f"{basis}-2c"
            orca_basis_x2c_2c.append(x2c_2c_basis)
        return orca_basis_x2c_2c

    @property
    def orca_basis_x2c_nmr(self):
        """The “-s” variants are augmented with additional tight functions for NMR shielding calculations. [5]."""
        orca_basis_x2c_nmr = []
        for basis in self.orca_basis_x2c:
            x2c_nmr_basis = f"{basis}-s"
            orca_basis_x2c_nmr.append(x2c_nmr_basis)
        return orca_basis_x2c_nmr

    @property
    def orca_basis_SARC(self):
        """Segmented all-electron relativistically contracted basis sets for use with the DKH2 and ZORA Hamiltonians.

        Available for elements beyond Krypton.
        Note: SARC/J is the general-purpose Coulomb-fitting auxiliary for all SARC orbital basis sets.
        """
        orca_basis_SARC = [
            "SARC-DKH-TZVP",
            "SARC-DKH-TZVPP",
            "SARC-ZORA-TZVP",
            "SARC-ZORA-TZVPP",
        ]
        return [basis.lower() for basis in orca_basis_SARC]

    @property
    def orca_basis_SARC2(self):
        """SARC basis sets of valence quadruple-zeta quality for lanthanides, with NEVPT2-optimized (3g2h) polarization
        functions.

        Suitable for accurate calculations using correlated wavefunction methods.
        Note: Can be called without the polarization functions using ...-QZV.
        Each basis set has a large dedicated /JK auxiliary basis set for simultaneous Coulomb and exchange fitting.
        """  # noqa: D205
        orca_basis_SARC2 = [
            "SARC2-DKH-QZVP",
            "SARC2-ZORA-QZVP",
            "SARC2-DKH-QZV",
            "SARC2-ZORA-QZV",
        ]
        return [basis.lower() for basis in orca_basis_SARC2]

    @property
    def orca_basis_Jensen(self):
        orca_basis_Jensen = []
        for basis in self.ORCA_JENSEN_BASIS_SETS:
            if basis.endswith("-n"):
                for i in range(5):
                    jensen_basis = basis.replace("-n", f"-{i!s}")
                    orca_basis_Jensen.append(jensen_basis)
        return [basis.lower() for basis in orca_basis_Jensen]

    @property
    def orca_basis_Sapporo(self):
        orca_basis_Sapporo = []
        for basis in self.ORCA_SAPPORO_BASIS_SETS:
            if "-nZP" in basis:
                for i in ["D", "T", "Q"]:
                    sapporo_basis = basis.replace("-nZP", f"-{i}ZP")
                    orca_basis_Sapporo.append(sapporo_basis)
        return [basis.lower() for basis in orca_basis_Sapporo]

    @property
    def orca_basis_cc(self):
        orca_basis_cc = []
        for basis in self.ORCA_CORRELATION_CONSISTENT_BASIS_SETS:
            if "VnZ" in basis and "pw" not in basis and "(+d)" not in basis:
                for i in ["D", "T", "Q", "5", "6"]:
                    cc_basis = basis.replace("VnZ", f"V{i}Z")
                    orca_basis_cc.append(cc_basis)
            else:
                for i in ["D", "T", "Q", "5"]:
                    cc_basis = basis.replace("Vn", f"V{i}")
                    orca_basis_cc.append(cc_basis)

        return [basis.lower() for basis in orca_basis_cc]

    @property
    def orca_basis_pa_cc(self):
        orca_basis_pa_cc = []
        for basis in self.ORCA_PARTIALLY_AUGMENTED_CC_BASIS_SETS:
            if basis.startswith("apr"):
                orca_basis_pa_cc.append(basis)
            elif basis.startswith("may"):
                for i in ["T", "Q"]:
                    may_basis = basis.replace(
                        "(n+d)", f"({i}+d)"
                    )  # (n = T, Q): sp (T), spd (Q) on Li-Ca
                    orca_basis_pa_cc.append(may_basis)
            elif basis.startswith(("jun", "jul", "maug")):
                for i in ["D", "T", "Q"]:
                    jun_jul_aug_basis = basis.replace("(n+d)", f"({i}+d)")
                    # (n = D, T, Q): sp (D), spd (T), spdf (Q) on Li-Ca for jun
                    # (n = D, T, Q): spd (D), spdf (T), spdfg (Q) on Li-Ca for jul
                    # same as jun-, may-, and apr- for n = D, T, and Q, respectively for maug
                    orca_basis_pa_cc.append(jun_jul_aug_basis)
        return [basis.lower() for basis in orca_basis_pa_cc]

    @property
    def orca_basis_DKH_cc(self):
        """DKH versions of correlation-consistent basis sets."""
        orca_basis_DKH_cc = []
        for basis in self.ORCA_CORRELATION_CONSISTENT_BASIS_SETS:
            if basis not in ("cc-pCVnZ", "aug-cc-pCVnZ", "cc-pVn(+d)Z"):
                for i in ["D", "T", "Q", "5"]:
                    dkh_cc_basis = basis.replace("Vn", f"V{i}")
                    dkh_cc_basis = f"{dkh_cc_basis}-DK"
                    orca_basis_DKH_cc.append(dkh_cc_basis)
            if basis in ("cc-pVnZ", "cc-pwCVnZ"):
                for i in ["D", "T", "Q"]:
                    dkh_cc_basis = basis.replace("Vn", f"V{i}")
                    dkh_cc_basis = f"{dkh_cc_basis}-DK3"
                    orca_basis_DKH_cc.append(dkh_cc_basis)
        return [basis.lower() for basis in orca_basis_DKH_cc]

    @property
    def orca_basis_ECP_cc(self):
        """ECP-based versions of correlation-consistent basis sets."""
        orca_basis_ECP_cc = []
        for basis in self.ORCA_CORRELATION_CONSISTENT_BASIS_SETS:
            if basis not in ("cc-pCVnZ", "aug-cc-pCVnZ", "cc-pVn(+d)Z"):
                for i in ["D", "T", "Q", "5"]:
                    ecp_cc_basis = basis.replace("Vn", f"V{i}")
                    ecp_cc_basis = f"{ecp_cc_basis}-PP"
                    orca_basis_ECP_cc.append(ecp_cc_basis)
        return [basis.lower() for basis in orca_basis_ECP_cc]

    @property
    def orca_basis_f12_cc(self):
        orca_basis_f12_cc = []
        for basis in self.ORCA_F12_F12_CABS_BASIS_SETS:
            if basis not in ("aug-cc-pVnZ-PP-OptRI", "aug-cc-pwCVnZ-PP-OptRI"):
                for i in ["D", "T", "Q"]:
                    f12_cc_basis = basis.replace("VnZ", f"V{i}Z")
                    orca_basis_f12_cc.append(f12_cc_basis)
            else:
                for i in ["D", "T", "Q", "5"]:
                    f12_cc_basis = basis.replace("VnZ", f"V{i}Z")
                    orca_basis_f12_cc.append(f12_cc_basis)
        return [basis.lower() for basis in orca_basis_f12_cc]

    @property
    def orca_basis_ANO(self):
        orca_basis_ANO = []
        for basis in self.ORCA_ANO_BASIS_SETS:
            if basis == "ANO-pVnZ":
                for i in ["D", "T", "Q", "5", "6"]:
                    ano_basis = basis.replace("VnZ", f"V{i}Z")
                    orca_basis_ANO.append(ano_basis)
            elif basis in ("saug-ANO-pVnZ", "aug-ANO-pVnZ"):
                for i in ["D", "T", "Q", "5"]:
                    ano_basis = basis.replace("VnZ", f"V{i}Z")
                    orca_basis_ANO.append(ano_basis)
            elif basis == "ANO-RCC-FULL":
                orca_basis_ANO.append(basis)
            elif basis == "ANO-RCC-nZP":
                for i in ["D", "T", "Q"]:
                    ano_basis = basis.replace("nZP", f"{i}ZP")
                    orca_basis_ANO.append(ano_basis)
        return [basis.lower() for basis in orca_basis_ANO]

    @property
    def orca_basis_misc_specialized(self):
        orca_basis_misc_specialized = []
        for basis in self.ORCA_MISC_SPECIALIZED_BASIS_SETS:
            if basis != "Partridge-n":
                orca_basis_misc_specialized.append(basis)
            else:
                for i in range(1, 5):
                    special_basis = basis.replace("-n", f"-{i!s}")
                    orca_basis_misc_specialized.append(special_basis)
        return [basis.lower() for basis in orca_basis_misc_specialized]

    @property
    def orca_auxiliary_basis_coulomb(self):
        """Auxiliary basis sets for Coulomb fitting."""
        return [
            basis.lower() for basis in self.ORCA_AUXILIARY_COULOMB_BASIS_SETS
        ]

    @property
    def orca_auxiliary_basis_coulomb_exchange(self):
        """Auxiliary basis sets for simultaneously fitting Coulomb and exchange.

        Fitting basis sets developed by Weigend for fitting simultaneously Coulomb and exchange energies.
        They are quite large and accurate. They fit SCF energies very well but even if they are large they do not fit
        correlation as well as the dedicated “/C” auxiliary basis sets.
        """
        orca_auxiliary_basis_coulomb_exchange = []
        for basis in self.ORCA_AUXILIARY_COULOMB_EXCHANGE_BASIS_SETS:
            if basis in ("cc-pVnZ/JK", "aug-cc-pVnZ/JK"):
                for i in ["T", "Q", "5"]:
                    cx_basis = basis.replace("VnZ", f"V{i}Z")
                    orca_auxiliary_basis_coulomb_exchange.append(cx_basis)
            else:
                orca_auxiliary_basis_coulomb_exchange.append(basis)
        return [
            basis.lower() for basis in orca_auxiliary_basis_coulomb_exchange
        ]

    @property
    def orca_auxiliary_basis_cc(self):
        orca_auxiliary_basis_cc = []
        for basis in self.ORCA_AUXILIARY_CC_BASIS_SETS:
            if "VnZ" not in basis:
                orca_auxiliary_basis_cc.append(basis)
            else:  # noqa: PLR5501
                if basis in ("cc-pVnZ/C", "aug-cc-pVnZ/C"):
                    for i in ["D", "T", "Q", "5", "6"]:
                        aux_cc_basis = basis.replace("VnZ", f"V{i}Z")
                        orca_auxiliary_basis_cc.append(aux_cc_basis)
                elif basis in ("cc-pwCVnZ/C", "aug-cc-pwCVnZ/C"):
                    for i in ["D", "T", "Q", "5"]:
                        aux_cc_basis = basis.replace("VnZ", f"V{i}Z")
                        orca_auxiliary_basis_cc.append(aux_cc_basis)
                else:
                    for i in ["D", "T", "Q"]:
                        aux_cc_basis = basis.replace("VnZ", f"V{i}Z")
                        orca_auxiliary_basis_cc.append(aux_cc_basis)
        return [basis.lower() for basis in orca_auxiliary_basis_cc]

    @property
    def orca_auxiliary_basis_autoaux(self):
        return [basis.lower() for basis in self.ORCA_AUXILIARY_AUTOAUX]

    @property
    def orca_all_extrapolation_basis_sets(self):  # noqa: PLR0912
        orca_extrapolation_all_basis_sets = []
        orca_extrapolation_basis_sets = []
        list_of_bas = [
            "cc",
            "aug-cc",
            "cc-core",
            "ano",
            "saug-ano",
            "aug-ano",
            "def2",
        ]
        methods = ["MP2", "DLPNO-CCSD(T)"]
        method_details = ["LoosePNO", "NormalPNO", "TightPNO"]

        for basis in self.ORCA_EXTRAPOLATION_BASIS:
            for bas in list_of_bas:
                new_basis = basis.replace("bas", f"{bas}")
                if "n/m" in new_basis:
                    for n in range(2, 5):
                        n_basis = new_basis.replace("n/", f"{n}/")
                        for m in range(3, 6):
                            if m > n:
                                m_basis = n_basis.replace("/m", f"/{m}")
                                if (
                                    m_basis
                                    not in orca_extrapolation_basis_sets
                                ):
                                    orca_extrapolation_basis_sets.append(
                                        m_basis
                                    )
                elif "n," in new_basis:
                    for n in range(2, 6):
                        n_basis = new_basis.replace("n,", f"{n},")
                        if n_basis not in orca_extrapolation_basis_sets:
                            orca_extrapolation_basis_sets.append(n_basis)
                elif (
                    "ExtrapolateEP3" in new_basis
                    and new_basis not in orca_extrapolation_basis_sets
                ):
                    orca_extrapolation_basis_sets.append(new_basis)

        for basis in orca_extrapolation_basis_sets:
            if "[method,method-details]" in basis:
                for method in methods:
                    new_basis = basis.replace("[method,", f"{method},")
                    for method_detail in method_details:
                        new_method_basis = new_basis.replace(
                            "method-details]", method_detail
                        )
                        if (
                            new_method_basis
                            not in orca_extrapolation_all_basis_sets
                        ):
                            orca_extrapolation_all_basis_sets.append(
                                new_method_basis
                            )

        orca_extrapolation_basis_sets = [
            basis
            for basis in orca_extrapolation_basis_sets
            if "[method,method-details]" not in basis
        ]
        return [
            basis.lower()
            for basis in orca_extrapolation_basis_sets
            + orca_extrapolation_all_basis_sets
        ]

    @property
    def orca_all_methods(self):
        return self.orca_functionals + self.orca_ab_initio

    @property
    def orca_all_basis_sets(self):
        return (
            self.orca_basis_pople
            + self.orca_basis_with_polarization
            + self.orca_basis_with_polarization_and_diffusion
            + self.orca_basis_karlsruhe_def2
            + self.orca_basis_karlsruhe_def
            + self.orca_basis_karlsruhe_minimally_augmented
            + self.orca_basis_karlsruhe_rappoport_property
            + self.orca_basis_karlsruhe_Dirac_Fock_ECPs
            + self.orca_basis_relativistic_DKH_ZORA
            + self.orca_basis_relativistic_DKH_ZORA_ma
            + self.orca_basis_x2c
            + self.orca_basis_x2c_2c
            + self.orca_basis_x2c_nmr
            + self.orca_basis_SARC
            + self.orca_basis_SARC2
            + self.orca_basis_Jensen
            + self.orca_basis_Sapporo
            + self.orca_basis_cc
            + self.orca_basis_pa_cc
            + self.orca_basis_DKH_cc
            + self.orca_basis_ECP_cc
            + self.orca_basis_f12_cc
            + self.orca_basis_ANO
            + self.orca_basis_misc_specialized
        )

    @property
    def orca_all_auxiliary_basis_sets(self):
        return (
            self.orca_auxiliary_basis_coulomb
            + self.orca_auxiliary_basis_coulomb_exchange
            + self.orca_auxiliary_basis_cc
            + self.orca_auxiliary_basis_autoaux
        )

    @property
    def orca_all_ECPs(self):
        return [ecp.lower() for ecp in self.ORCA_ECPS]

    @property
    def orca_all_solvents(self):
        orca_all_solvent_ids = [
            solvent.lower() for solvent in self.ORCA_SOLVENT_IDS
        ]
        orca_all_solvent_ids_short_names = [
            solvent.lower() for solvent in self.ORCA_SOLVENT_IDS_SHORT_NAMES
        ]
        return orca_all_solvent_ids + orca_all_solvent_ids_short_names

    @property
    def orca_density_options(self):
        return [i.lower() for i in self.O_DENSITY_OPTIONS]

    @property
    def orca_qmmm_jobtype(self):
        return [i.lower() for i in self.ORCA_QMMM_JOBTYPE]

    @property
    def orca_qm2_built_in_methods(self):
        return [i.lower() for i in self.ORCA_QM2_BUILT_IN_METHODS]


orca_ref = ORCARefs()
ORCA_ALL_FUNCTIONALS = orca_ref.orca_functionals
ORCA_ALL_AB_INITIO = orca_ref.orca_ab_initio
ORCA_ALL_METHODS = orca_ref.orca_all_methods
ORCA_ALL_BASIS_SETS = orca_ref.orca_all_basis_sets
ORCA_ALL_AUXILIARY_BASIS_SETS = orca_ref.orca_all_auxiliary_basis_sets
ORCA_ALL_EXTRAPOLATION_BASIS_SETS = orca_ref.orca_all_extrapolation_basis_sets
ORCA_ALL_JOB_TYPES = orca_ref.ORCA_JOB_TYPES
ORCA_ALL_SOLVENTS = orca_ref.orca_all_solvents
ORCA_ALL_SOLVENT_MODELS = orca_ref.ORCA_SOLVENT_MODELS
ORCA_SCF_CONVERGENCE = orca_ref.ORCA_SCF_CONVERGENCE_CRITERIA
ORCA_ALL_DENSITY_OPTIONS = orca_ref.orca_density_options
ORCA_ALL_SCF_ALGORITHMS = orca_ref.ORCA_SCF_ALGORITHMS
ORCA_ALL_DISPERSION_CORRECTIONS = orca_ref.ORCA_DISPERSION_CORRECTIONS
ORCA_ALL_QMMM_JOBTYPE = orca_ref.orca_qmmm_jobtype
ORCA_ALL_QM2_BUILT_IN_METHODS = orca_ref.orca_qm2_built_in_methods
