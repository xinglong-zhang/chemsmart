"""
Gaussian CREST conformer-ensemble job implementation.

Provides the GaussianCrestJob for running Gaussian optimizations on
conformers generated by CREST (or any external conformer generator).
It batches multiple conformer optimizations and offers utilities for
progress and completion tracking across the ensemble.
"""

import logging

from chemsmart.jobs.gaussian.job import GaussianGeneralJob, GaussianJob

logger = logging.getLogger(__name__)


class GaussianCrestJob(GaussianJob):
    """
    Gaussian job class for CREST conformer ensemble calculations.

    Manages multiple conformer optimization jobs from a CREST
    conformer ensemble. Handles batch processing of conformers
    with configurable subset selection and completion tracking.

    This job type is designed for high-throughput conformer
    optimization workflows where multiple structures need to be
    processed systematically.

    Attributes:
        TYPE (str): Job type identifier ('g16crest').
        all_conformers (list[Molecule]): Conformers to be optimized.
        num_confs_to_opt (int): Number of conformers to run (slice limit).

    Properties:
        num_conformers (int): Total number of conformers in the ensemble.
        last_run_job_index (int): Index of the first incomplete job; equals
            total number if all jobs are complete.
        all_conformers_jobs (list[GaussianGeneralJob]): Prepared jobs for
            all conformers.
        incomplete_conformers_jobs (list[GaussianGeneralJob]): Prepared
            jobs that are not yet complete.
    """

    TYPE = "g16crest"

    def __init__(
        self,
        molecules,
        settings=None,
        label=None,
        jobrunner=None,
        num_confs_to_run=None,
        grouping_strategy=None,
        skip_completed=True,
        **kwargs,
    ):
        """
        Initialize a Gaussian CREST conformer ensemble calculation.

        Sets up a multi-conformer optimization job from a list of
        conformer structures. Validates input and configures the
        number of conformers to process.

        Args:
            molecules (list[Molecule]): List of Molecule objects representing
                conformers to optimize.
            settings (GaussianJobSettings): Calculation configuration settings.
            label (str, optional): Base label for conformer jobs.
            jobrunner (JobRunner, optional): Job execution handler.
            num_confs_to_run (int, optional): Number of conformers to
                optimize. Defaults to all conformers.
            **kwargs: Additional keyword arguments for parent class.

        Raises:
            ValueError: If molecules fails basic list validation.
        """
        if not isinstance(molecules, list) and len(molecules) == 0:
            raise ValueError("Molecules must be a list of Molecule objects.")

        super().__init__(
            molecule=molecules[0],
            settings=settings,
            label=label,
            jobrunner=jobrunner,
            skip_completed=skip_completed,
            **kwargs,
        )

        if num_confs_to_run is None:
            num_confs_to_run = len(molecules)

        self.num_confs_to_opt = num_confs_to_run

        # if grouping strategy is provided, set the grouper
        # and carry out the grouping before running the group of molecules
        if grouping_strategy is not None:
            logger.info(f"Using grouping strategy: {grouping_strategy}")
            from chemsmart.utils.grouper import StructureGrouperFactory

            logger.info(f"Total structures to group: {len(molecules)}")
            grouper = StructureGrouperFactory.create(
                molecules, strategy=grouping_strategy, **kwargs
            )
            grouper.group()
            unique_molecules = grouper.unique()
            self.grouper = grouper
            logger.debug(f"Grouping strategy: {grouper.__repr__()}")
            logger.info(f"Number of unique groups: {len(unique_molecules)}")
            logger.info(f"Unique molecules: {unique_molecules}")
            self.all_conformers = unique_molecules

        else:
            # if no grouping strategy is provided, use all molecules as conformers
            self.grouper = None
            self.all_conformers = molecules

    @property
    def num_conformers(self):
        """
        Get the total number of conformers in the ensemble.

        Returns:
            int: Total number of conformer structures loaded.
        """
        return len(self.all_conformers)

    @property
    def last_run_job_index(self):
        """
        Get the index of the first incomplete job.

        Tracks progress through the conformer ensemble by identifying
        the next job to run. Useful for resuming interrupted
        calculations.

        Returns:
            int: Index of the first incomplete job; equals total number
                of conformers if all jobs are complete.
        """
        return self._check_last_finished_job_index()

    @property
    def all_conformers_jobs(self):
        """
        Get all conformer optimization jobs in the ensemble.

        Returns:
            list: List of GaussianGeneralJob objects for all conformers.
        """
        return self._prepare_all_jobs()

    @property
    def incomplete_conformers_jobs(self):
        """
        Get incomplete conformer optimization jobs.

        Filters the job list to return only those jobs that have not
        yet completed successfully. Useful for selective resubmission.

        Returns:
            list: List of incomplete GaussianGeneralJob objects.
        """
        return [
            job for job in self.all_conformers_jobs if not job.is_complete()
        ]

    def _check_last_finished_job_index(self):
        """
        Find the index of the first incomplete job in the sequence.

        Iterates through all conformer jobs to identify the last
        point of progress. This is used for progress tracking and
        resuming calculations.

        Returns:
            int: Index of the first incomplete job, or total number of
                conformers if all jobs are complete.
        """
        for i, job in enumerate(self.all_conformers_jobs):
            if not job.is_complete():
                return i

        # If all complete
        return self.num_conformers

    def _prepare_all_jobs(self):
        """
        Create optimization jobs for all conformers in the ensemble.

        Generates a list of GaussianGeneralJob objects, one for each
        conformer structure. Each job gets a unique label based on
        the base label and conformer index.

        Returns:
            list: List of GaussianGeneralJob objects for all conformers.
        """
        jobs = []
        for i in range(self.num_conformers):
            label = f"{self.label}_c{i + 1}"  # 1-indexed for conformers
            jobs += [
                GaussianGeneralJob(
                    molecule=self.all_conformers[i],
                    settings=self.settings,
                    label=label,
                    jobrunner=self.jobrunner,
                    skip_completed=self.skip_completed,
                )
            ]
        return jobs

    def _run_all_jobs(self):
        """
        Execute all conformer optimization jobs up to the specified limit.

        Runs the conformer optimization jobs sequentially up to the
        number specified in num_confs_to_opt. This allows for partial
        ensemble processing when needed.
        """
        # Check if jobs should be run in serial based on jobrunner flag
        if self.jobrunner and self.jobrunner.run_in_serial:
            logger.info("Running conformer jobs in serial mode (one after another)")
            for job in self.all_conformers_jobs[: self.num_confs_to_opt]:
                job.run()
                # Enforce that job completed before proceeding to next
                if not job.is_complete():
                    logger.warning(
                        f"Conformer job {job.label} did not complete successfully. "
                        f"Stopping serial execution."
                    )
                    break
        else:
            logger.info("Running conformer jobs using default behavior")
            for job in self.all_conformers_jobs[: self.num_confs_to_opt]:
                job.run()

    def _run(self):
        """
        Execute the CREST conformer ensemble calculation.

        Main execution method that initiates all conformer optimization
        jobs. This is called internally by the job runner framework.
        """
        self._run_all_jobs()

    def is_complete(self):
        """
        Check if all conformer optimization jobs are complete.

        Returns:
            bool: True if all required conformer optimizations have
                completed successfully, False otherwise.
        """
        return self._run_all_crest_jobs_are_complete()

    def _run_all_crest_jobs_are_complete(self):
        """
        Verify completion status of all required conformer jobs.

        Checks the completion status of all conformer optimization
        jobs up to the specified limit (num_confs_to_opt).

        Returns:
            bool: True if all required jobs are complete, False otherwise.
        """
        return all(
            job.is_complete()
            for job in self.all_conformers_jobs[: self.num_confs_to_opt]
        )
