import copy
import logging
import os
import re

from chemsmart.io.gaussian import GAUSSIAN_SOLVATION_MODELS
from chemsmart.io.gaussian.gengenecp import GenGenECPSection
from chemsmart.jobs.settings import MolecularJobSettings
from chemsmart.utils.periodictable import PeriodicTable

pt = PeriodicTable()


logger = logging.getLogger(__name__)


class GaussianJobSettings(MolecularJobSettings):
    def __init__(
        self,
        ab_initio=None,
        functional=None,
        basis=None,
        semiempirical=None,
        charge=None,
        multiplicity=None,
        chk=True,
        job_type=None,
        title=None,
        freq=False,
        numfreq=False,
        dieze_tag=None,
        solvent_model=None,
        solvent_id=None,
        additional_opt_options_in_route=None,
        additional_route_parameters=None,
        route_to_be_written=None,
        modred=None,
        gen_genecp_file=None,
        heavy_elements=None,
        heavy_elements_basis=None,
        light_elements_basis=None,
        custom_solvent=None,
        append_additional_info=None,
        forces=False,
        input_string=None,
        **kwargs,
    ):
        super().__init__(
            ab_initio=ab_initio,
            functional=functional,
            basis=basis,
            semiempirical=semiempirical,
            charge=charge,
            multiplicity=multiplicity,
            freq=freq,
            numfreq=numfreq,
            job_type=job_type,
            title=title,
            solvent_model=solvent_model,
            solvent_id=solvent_id,
            additional_route_parameters=additional_route_parameters,
            route_to_be_written=route_to_be_written,
            modred=modred,
            gen_genecp_file=gen_genecp_file,
            heavy_elements=heavy_elements,
            heavy_elements_basis=heavy_elements_basis,
            light_elements_basis=light_elements_basis,
            custom_solvent=custom_solvent,
            forces=forces,
            input_string=input_string,
            **kwargs,
        )
        self.chk = chk
        self.dieze_tag = dieze_tag
        self.additional_opt_options_in_route = additional_opt_options_in_route
        self.append_additional_info = append_additional_info
        self._route_string = None

        if gen_genecp_file is not None and "~" in gen_genecp_file:
            gen_genecp_file = os.path.expanduser(gen_genecp_file)
        self.gen_genecp_file = gen_genecp_file

        if forces is True and freq is True:
            raise ValueError(
                "Frequency and Force calculations cannot be performed by Gaussian at the same time!\n"
                'Such an input file will give "Illegal IType or MSType generated by parse." error.'
            )

    @property
    def genecp(self):
        return (
            self.gen_genecp_file is not None or self.heavy_elements is not None
        )

    def merge(
        self,
        other,
        keywords=("charge", "multiplicity", "title"),
        merge_all=False,
    ):
        """Overwrite self settings with other settings.

        Args:
            keywords (list): Specific list of keywords to merge.
                Defaults to charge and multiplicity.
                If None, all settings will be merged (Caution: may cause issue if e.g.,
                genecp log file used to prepare input without genecp).
            other (JobSettings, dict): Settings to merge. Can also take the form of a dictionary
            merge_all (bool): If True, merge all settings.
            If False, only merge the settings specified in keywords.
        """
        other_dict = other if isinstance(other, dict) else other.__dict__

        if merge_all:
            # Update self with other for all
            merged_dict = self.__dict__.copy()
            merged_dict.update(other_dict)
            return type(self)(**merged_dict)

        if keywords is not None:
            other_dict = {
                k: other_dict[k] for k in keywords if k in other_dict
            }
        # Update self with other
        merged_dict = self.__dict__.copy()
        merged_dict.update(other_dict)
        return type(self)(**merged_dict)

    def copy(self):
        return copy.deepcopy(self)

    def __getitem__(self, key):
        return self.__dict__[key]

    def __eq__(self, other):
        """Two settings objects are equal if all their attributes are equal."""
        if type(self) is not type(other):
            return NotImplemented

        # Exclude append_additional_info from the comparison
        self_dict = self.__dict__
        self_dict.pop("append_additional_info")

        other_dict = other.__dict__
        other_dict.pop("append_additional_info")

        is_equal = self_dict == other_dict
        if not is_equal:
            import dictdiffer

            logger.info("Gaussian job settings are not equal.")
            for diff in list(dictdiffer.diff(self_dict, other_dict)):
                logger.info(f"Difference: {diff}")
        return self_dict == other_dict

    @classmethod
    def from_comfile(cls, filename):
        """Return Gaussian settings object from a given gaussian.com file.

        Args:
            filename (str): file path of the .com file string to be supplied.
        """
        from chemsmart.io.gaussian.input import Gaussian16Input

        com_path = os.path.abspath(filename)
        gaussian_settings_from_comfile = Gaussian16Input(
            filename=com_path
        ).read_settings()
        return gaussian_settings_from_comfile

    @classmethod
    def from_inpfile(cls, filename):
        """Return Gaussian settings object from a given orca.inp file.

        Args:
            filename (str): file path of the .inp file string to be supplied.
        """
        from chemsmart.io.orca.input import ORCAInput

        inp_path = os.path.abspath(filename)
        logger.info(f"Return Settings object from inp file: {inp_path}")
        orca_settings_from_inpfile = ORCAInput(
            filename=inp_path
        ).read_settings()
        gaussian_default_settings = cls.default()
        gaussian_settings_from_inpfile = gaussian_default_settings.merge(
            orca_settings_from_inpfile, merge_all=True
        )
        logger.info(
            f"with settings: {gaussian_settings_from_inpfile.__dict__}"
        )
        return gaussian_settings_from_inpfile

    @classmethod
    def from_logfile(cls, filename):
        """Return Gaussian settings object from a given gaussian.log file.

        Args:
            filename (str): file path of the .log file to be supplied.
        """
        log_path = os.path.abspath(filename)
        from chemsmart.io.gaussian.output import (
            Gaussian16Output,
            Gaussian16OutputWithPBC,
        )

        logger.info(f"Return Settings object from logfile: {log_path}")
        try:
            settings = Gaussian16Output(filename=log_path).read_settings()
        except ValueError:
            settings = Gaussian16OutputWithPBC(
                filename=log_path
            ).read_settings()

        return settings

    @classmethod
    def from_outfile(cls, filename):
        """Return Gaussian job settings from ORCA output file."""
        from chemsmart.io.orca.output import ORCAOutput

        out_path = os.path.abspath(filename)
        logger.info(
            f"Return Settings object from ORCA .out filename: {out_path}"
        )
        orca_settings_from_outfile = ORCAOutput(
            filename=out_path
        ).read_settings()
        gaussian_default_settings = cls.default()
        gaussian_settings_from_outfile = gaussian_default_settings.merge(
            orca_settings_from_outfile, merge_all=True
        )
        logger.info(
            f"with settings: {gaussian_settings_from_outfile.__dict__}"
        )
        return gaussian_settings_from_outfile

    @classmethod
    def default(cls):
        return cls(
            ab_initio=None,
            functional=None,
            basis=None,
            semiempirical=None,
            charge=None,
            multiplicity=None,
            chk=True,
            job_type=None,
            title="Gaussian job with default settings",
            freq=True,
            numfreq=False,
            dieze_tag=None,
            solvent_model=None,
            solvent_id=None,
            additional_opt_options_in_route=None,
            additional_route_parameters=None,
            route_to_be_written=None,
            modred=None,
            gen_genecp_file=None,
            heavy_elements=None,
            heavy_elements_basis=None,
            light_elements_basis=None,
            custom_solvent=None,
            append_additional_info=None,
            forces=False,
            input_string=None,
        )

    @classmethod
    def from_filepath(cls, filepath, **kwargs):
        if filepath.endswith((".com", ".gjf")):
            return cls.from_comfile(filepath)
        if filepath.endswith(".inp"):
            return cls.from_inpfile(filepath)
        if filepath.endswith(".log"):
            return cls.from_logfile(filepath)
        raise ValueError(f"Could not create {cls} from {filepath}")

    @property
    def route_string(self):
        if self.route_to_be_written is not None:
            route_string = self._get_route_string_from_user_input()
        else:
            route_string = self._get_route_string_from_jobtype()
        logger.debug(f"Route for settings {self}: {route_string}")
        return route_string

    @route_string.setter
    def route_string(self, value):
        self._route_string = value

    def _get_route_string_from_user_input(self):
        route_string = self.route_to_be_written
        if not route_string.startswith("#"):
            route_string = (
                f"#{self.dieze_tag} {route_string}"
                if self.dieze_tag is not None
                else f"# {route_string}"
            )
        return route_string

    def get_light_elements(self, molecule):
        if self.heavy_elements is None:
            return None

        unique_atoms = set(molecule.chemical_symbols)
        light_elements_set = unique_atoms - set(self.heavy_elements)
        light_elements_list = list(light_elements_set)

        sorted_light_elements_list = pt.sorted_periodic_table_list(
            light_elements_list
        )
        logger.info(
            f"Light elements in structure: {sorted_light_elements_list}"
        )
        return sorted_light_elements_list

    def _get_route_string_from_jobtype(self):
        route_string = ""

        dieze_tag = self._get_dieze_tag()
        route_string += dieze_tag

        job_route = self._get_job_route()
        route_string += job_route

        freq_string = self._get_freq_string()
        route_string += freq_string

        level_of_theory_string = self._get_level_of_theory_string()
        route_string += level_of_theory_string

        force_string = self._get_force_string()
        route_string += force_string

        solvent_string = self._get_solvent_string()
        route_string += solvent_string

        additional_string = self._get_additional_string()
        route_string += additional_string

        return route_string

    def _get_dieze_tag(self):
        """Get dieze tag from job type."""
        route_string = ""
        if self.dieze_tag is not None:
            route_string += (
                f"#{self.dieze_tag}"  # e.g. dieze_tag='p' to get '#p'
            )
        else:
            route_string += "#"
        return route_string

    def _get_job_route(self):
        """Get route corresponding to job type."""
        route_string = ""
        # write opt with additional options e.g., maxstep, calcall etc
        if self.additional_opt_options_in_route is not None:
            if self.job_type == "opt":
                route_string += (
                    f" opt=({self.additional_opt_options_in_route})"
                )
            elif self.job_type == "ts":
                if "calcall" not in self.additional_opt_options_in_route:
                    route_string += f" opt=(ts,calcfc,noeigentest,{self.additional_opt_options_in_route})"
                else:
                    route_string += f" opt=(ts,noeigentest,{self.additional_opt_options_in_route})"
            elif self.job_type == "modred":
                route_string += f" opt=(modredundant,{self.additional_opt_options_in_route})"
            elif self.job_type == "scan":
                route_string += f" opt=(modredundant,{self.additional_opt_options_in_route})"
            elif self.job_type == "sp":
                route_string += ""
        elif self.additional_opt_options_in_route is None:
            if self.job_type == "opt":
                route_string += " opt"
            elif self.job_type == "ts":
                route_string += " opt=(ts,calcfc,noeigentest)"
            elif self.job_type == "modred":
                route_string += " opt=modredundant"
            elif self.job_type == "scan":
                route_string += " opt=modredundant"
            elif self.job_type == "sp":
                route_string += ""
        return route_string

    def _set_freq_from_job_type(self):
        """Set freq for different job type.
        Some sensible defaults have been used here."""
        if self.job_type in ["opt", "ts", "modred"]:
            self.freq = True
            self.numfreq = False
        elif self.job_type in ["sp", "scan"]:
            self.freq = False
            self.numfreq = False

    def _get_freq_string(self):
        """Get freq string for route."""
        route_string = ""
        self._set_freq_from_job_type()
        # write frequency
        if self.freq and not self.numfreq:
            route_string += " freq"
        elif not self.freq and self.numfreq:
            route_string += " freq=numer"
        elif self.freq and self.numfreq:
            raise ValueError(
                "Both freq and numfreq cannot be True at the same time!"
            )
        return route_string

    def _get_level_of_theory_string(self):
        """Get level of theory string for route."""
        route_string = ""

        # Determine computational method
        if self.semiempirical is not None:
            # Semiempirical methods do not require a basis set
            if self.basis is not None:
                logger.info(
                    "Warning: Basis set provided but not required for semiempirical methods."
                )
            route_string += f" {self.semiempirical}"

        elif self.ab_initio is not None and self.functional is None:
            # Ab initio method requires a basis set
            if self.basis is None:
                raise ValueError(
                    "Error: Basis set is required for ab initio methods."
                )
            route_string += f" {self.ab_initio} {self.basis}"

        elif self.functional is not None and self.ab_initio is None:
            # DFT method requires a basis set
            if self.basis is None:
                raise ValueError(
                    "Error: Basis set is required for DFT methods."
                )
            route_string += f" {self.functional} {self.basis}"

        elif self.ab_initio is not None and self.functional is not None:
            raise ValueError(
                "Error: Both ab initio and DFT functional provided.\n"
                "Specify only one."
            )

        else:
            raise ValueError("Error: No computational method provided.")

        return route_string

    def _get_force_string(self):
        """Get force string for route."""
        route_string = ""
        # write forces calculation
        if self.forces:
            route_string += " force"
        return route_string

    def _get_solvent_string(self):
        """Get solvent string for route."""
        route_string = ""
        if self.custom_solvent is not None:
            if self.solvent_model is None and self.solvent_id is None:
                route_string += (
                    " scrf=(pcm,read)"  # using pcm model as default
                )
            else:
                # Set default values if any of solvent_model or solvent_id are None
                solvent_model = self.solvent_model or "pcm"
                if self.solvent_id is None:
                    solvent_id = "read"
                elif self.solvent_id == "generic":
                    solvent_id = "generic,read"
                else:
                    solvent_id = self.solvent_id
                route_string += f" scrf=({solvent_model},solvent={solvent_id})"
        elif (
            self.solvent_model is not None and self.solvent_id is not None
        ):  # solvation is turned on
            route_string += (
                f" scrf=({self.solvent_model},solvent={self.solvent_id})"
            )
        elif (self.solvent_model is not None and self.solvent_id is None) or (
            self.solvent_model is None and self.solvent_id is not None
        ):  # if one is provided but the other not
            raise ValueError(
                f"Both solvent model and solvent ID need to be specified.\n"
                f"Currently, solvent model is {self.solvent_model} and solvent id is {self.solvent_id}!"
            )

        return route_string

    def _get_additional_string(self):
        """Get additional info string for route.
        Additional Route Parameters + job specific parameters."""
        route_string = ""

        # write additional parameters for route
        if self.additional_route_parameters is not None:
            route_string += f" {self.additional_route_parameters}"

        # write job type specific route
        if self.job_type == "nci":
            route_string += " output=wfn"  # output wavefunction file for NCI
        elif self.job_type == "wbi":
            route_string += " pop=nboread"  # write bond order matrix
        return route_string

    @property
    def _genecp_elements_specified(self):
        return (
            self.heavy_elements is not None
            and self.heavy_elements_basis is not None
        )

    @property
    def _genecp_file_specified(self):
        return self.gen_genecp_file is not None and os.path.exists(
            self.gen_genecp_file
        )

    def get_genecp_section(self, molecule):
        if self._genecp_elements_specified:
            logger.info(
                f"GENECP elements specified:\n"
                f"Heavy elements: {self.heavy_elements}\n"
                f"Heavy elements basis: {self.heavy_elements_basis}\n"
                f"Light elements basis: {self.light_elements_basis}\n"
            )
            # Method 1 for getting genecp
            # Need to supply self.heavy_elements, self.heavy_elements_basis
            # and self.light_elements_basis
            heavy_elements_in_structure = self.prune_heavy_elements(molecule)

            genecp_section = GenGenECPSection.from_bse_api(
                light_elements=self.get_light_elements(molecule),
                light_elements_basis=self.light_elements_basis,
                heavy_elements=heavy_elements_in_structure,
                heavy_elements_basis=self.heavy_elements_basis,
            )

        elif self._genecp_file_specified:
            logger.info(f"GENECP file specified: {self.gen_genecp_file}")
            # Method 2 for getting genecp:
            # Supplied path to genecp file
            genecp_section = GenGenECPSection.from_genecp_path(
                genecp_path=self.gen_genecp_file
            )
        else:
            raise ValueError("Could not get GenECPSection")
        return genecp_section

    def prune_heavy_elements(self, molecule):
        # heavy atoms list supplied from settings contains all heavy atoms needed for
        # heavy_atom_basis but in each structure, some heave atoms supplied from settings
        # may not appear in the structure
        if self.heavy_elements is None:
            return None
        return list(
            set(molecule.chemical_symbols).intersection(self.heavy_elements)
        )

    def _check_solvent(self, solvent_model):
        if solvent_model.lower() not in GAUSSIAN_SOLVATION_MODELS:
            raise ValueError(
                f"The specified solvent model {solvent_model} is not in \n"
                f"the available solvent models: {GAUSSIAN_SOLVATION_MODELS}"
            )


class GaussianIRCJobSettings(GaussianJobSettings):
    def __init__(
        self,
        predictor=None,
        recorrect=None,
        recalc_step=6,
        direction=None,
        maxpoints=512,
        maxcycles=128,
        stepsize=20,
        flat_irc=False,
        **kwargs,
    ):
        super().__init__(**kwargs)
        self.predictor = predictor
        self.recorrect = recorrect
        self.recalc_step = recalc_step
        self.direction = direction
        self.maxpoints = maxpoints
        self.maxcycles = maxcycles
        self.stepsize = stepsize
        self.flat_irc = flat_irc
        self.freq = False  # turn off freq calc for IRC jobs
        self.forces = False  # turn off forces calculations
        self.route_to_be_written = None

    def _get_route_string_from_jobtype(self):
        route_string = super()._get_route_string_from_jobtype()
        # if flat irc
        if self.flat_irc:
            # default route for flat IRC run if no options are specified
            self.predictor = (
                "LQA" if self.predictor is None else self.predictor
            )
            self.recorrect = (
                "never" if self.recorrect is None else self.recorrect
            )
            self.recalc_step = (
                -5 if self.recalc_step == 6 else self.recalc_step
            )

        # write job type specific route for irc
        if self.job_type == "ircf":
            self.direction = "forward"
        elif self.job_type == "ircr":
            self.direction = "reverse"

        if self.predictor is not None and self.recorrect is not None:
            route_string += (
                f" irc({self.predictor},calcfc,recorrect={self.recorrect},recalc={self.recalc_step},"
                f"stepsize={self.stepsize},{self.direction},maxpoints={self.maxpoints},maxcycle={self.maxcycles})"
            )
        elif self.predictor is None and self.recorrect is None:
            route_string += (
                f" irc(calcfc,recalc={self.recalc_step},{self.direction},"
                f"maxpoints={self.maxpoints},maxcycle={self.maxcycles})"
            )
        else:
            raise ValueError(
                f"Only one of predictor type and recorrect is specified, please check!\n"
                f"Predictor: {self.predictor}; Recorrect: {self.recorrect}"
            )

        if self.additional_route_parameters is not None:
            route_string += f" {self.additional_route_parameters}"

        return route_string


class GaussianLinkJobSettings(GaussianJobSettings):
    def __init__(
        self, link=True, link_route=None, stable="opt", guess="mix", **kwargs
    ):
        super().__init__(**kwargs)
        self.link = link
        self.link_route = link_route
        self.stable = stable
        self.guess = guess

    @property
    def link_route_string(self):
        if self.link_route is not None:
            link_route_string = self.link_route
            if self.functional not in self.link_route:
                link_route_string += f" {self.functional}"
            if self.basis not in self.link_route:
                link_route_string += f" {self.basis}"
            if "geom=check" not in self.link_route:
                link_route_string += " geom=check"
            if "guess=read" not in self.link_route:
                link_route_string += " guess=read"
            logger.debug(
                f"Link route for settings {self}: {link_route_string}"
            )
            return link_route_string

        link_route_string = self._get_link_route_string_from_jobtype()
        logger.debug(f"Link route for settings {self}: {link_route_string}")
        return link_route_string

    def _get_route_string_from_jobtype(self):
        route_string = super()._get_route_string_from_jobtype()
        # remove "opt or opt= and freq" from route string
        pattern = re.compile(r"opt\s*(=\s*(\(.*\)|\w+))?\s*", re.IGNORECASE)
        route_string_final = re.sub(pattern, "", route_string)
        route_string_final = route_string_final.replace("freq", "")
        # stable=opt guess=mix
        if self.stable:
            logger.debug(f"Stable: {self.stable}")
            route_string_final += f" stable={self.stable}"
        if self.guess:
            logger.debug(f"Guess: {self.guess}")
            route_string_final += f" guess={self.guess}"
        else:
            # other methods for link jobs - have not encountered yet,
            # but may be modified in future when needed
            pass

        return route_string_final

    def _get_link_route_string_from_jobtype(self):
        route_string = super()._get_route_string_from_jobtype()
        # remove "opt or opt= and freq" from route string

        if "geom=check" not in route_string:
            route_string += " geom=check"
        if "guess=read" not in route_string:
            route_string += " guess=read"
        return route_string


class GaussianTDDFTJobSettings(GaussianJobSettings):
    def __init__(
        self, states="singlets", root=1, nstates=3, eqsolv=None, **kwargs
    ):
        super().__init__(**kwargs)
        self.states = states
        self.root = root
        self.nstates = nstates
        self.eqsolv = eqsolv

    def _get_route_string_from_jobtype(self):
        route_string = super()._get_route_string_from_jobtype()

        if self.eqsolv is None:
            eqsolv = ""
        else:
            eqsolv_options = ["eqsolv", "noneqsolv"]
            assert (
                self.eqsolv.lower() in eqsolv_options
            ), f"Possible equilibrium solvation options are: {eqsolv_options}!"
            eqsolv = f",{self.eqsolv}"

        route_string += f" TD({self.states},nstates={self.nstates},root={self.root}{eqsolv})"

        return route_string


class GaussianQMMMJobSettings(GaussianJobSettings):

    def __init__(
        self,
        jobtype=None,
        high_level_functional=None,
        high_level_basis=None,
        high_level_force_field=None,
        medium_level_functional=None,
        medium_level_basis=None,
        medium_level_force_field=None,
        low_level_functional=None,
        low_level_basis=None,
        low_level_force_field=None,
        real_charge=None,
        real_multiplicity=None,
        int_charge=None,
        int_multiplicity=None,
        model_charge=None,
        model_multiplicity=None,
        high_level_atoms=None,
        medium_level_atoms=None,
        low_level_atoms=None,
        bonded_atoms=None,
        scale_factors=None,
        **kwargs,
    ):
        """Gaussian QM/MM Job Settings containing information to create a QM/MM Job.
        Args:
            job_type: different calculations support by Gaussian ONIOM, including:
                1.Single-point energy;
                2.Geometry optimization;
                3.Frequency analysis;
                4.Transition state search (QST2/QST3)
                5.IRC calculations
            high_level_functional/medium_level_functional/low_level_functional: Functional for high/medium/low level of theory
            high_level_basis/medium_level_basis/low_level_basis: Basis set for high/medium/low level of theory
            high_level_force_field/medium_level_force_field/low_level_force_field: Force field for high/medium/low level of theory (if specified)
            real_/int_/model_charge(int): Charge of real/intermediate/model system
            real_/int_/model_charge_multiplicity(int): Multiplicity of real/intermediate/model system
            high_level_atoms (list or string): List of high level atoms.
            medium_level_atoms (list) : List of medium level atoms.
            low_level_atoms (list): List of low level atoms.
            bonded_atoms (list of tuples): List of bonded atoms.
            scale_factors (dict) (optional):  A dictionary of scale factors for QM/MM calculations, where the key is the bonded atom pair indices and the value is a list of scale factors for (low, medium, high).
            **kwargs: Additional keyword arguments.

            Information about scale factors:
            The scale factors are used to scale the bond lengths between different layers.
            For example, in a two-layer ONIOM calculation, if a C-C bond is cut between low and high layers, the
            C atom from the low layer will be substituted by an H atom (link atom) when conducting the high-level
            calculation. Instead of directly placing an H atom at the position of the C atom, the link atom (H)
            needs to be aligned along with the bond vector of the original C-C bond.
            Note that the bond distances of C-C and C-H bond are different. Both scale_factor1 and scale_factor2
            can be set as 0.709, which represents the ratio of a standard C-C bond length (1.084 Å) to a standard
            C-H bond length (1.528 Å). That is, a link atom (H) is placed at a distance of 0.709 times the bond
            length of the original C-C bond for both low-level and high-level calculations.
            If not specified, scale factors will be calculated by the ratio of covalent radiis. If only one scale
            factor is specified, it will be used for all layers. If two scale factors are specified for a 3-layer
            ONIOM calculation, both the high- and medium-layer will use the second scale factor.
        """
        super().__init__(**kwargs)
        self.jobtype = jobtype
        self.high_level_functional = high_level_functional
        self.high_level_basis = high_level_basis
        self.high_level_force_field = high_level_force_field
        self.medium_level_functional = medium_level_functional
        self.medium_level_basis = medium_level_basis
        self.medium_level_force_field = medium_level_force_field
        self.low_level_functional = low_level_functional
        self.low_level_basis = low_level_basis
        self.low_level_force_field = low_level_force_field
        self.real_charge = real_charge
        self.real_multiplicity = real_multiplicity
        self.int_charge = int_charge
        self.int_multiplicity = int_multiplicity
        self.model_charge = model_charge
        self.model_multiplicity = model_multiplicity
        self.high_level_atoms = high_level_atoms
        self.medium_level_atoms = medium_level_atoms
        self.low_level_atoms = low_level_atoms
        self.bonded_atoms = bonded_atoms
        self.scale_factors = scale_factors
        # If the user only specifies the parameters of two layers, the low-level layer will be omitted

        # populate self.functional and self.basis so that
        # it will not raise errors in parent class
        self.functional = (
            self.high_level_functional
            or self.medium_level_functional
            or self.low_level_functional
        )
        self.basis = (
            self.high_level_basis
            or self.medium_level_basis
            or self.low_level_basis
        )
        self.title = "Gaussian QM/MM job"
        self._route_string = self.get_qmmm_level_of_theory_string()

        if self.real_charge and self.real_multiplicity:
            # the charge and multiplicity of the real system equal to
            # that of the low_level_charge and low_level_multiplicity
            self.charge = self.real_charge
            self.multiplicity = self.real_multiplicity

    @property
    def charge_and_multiplicity_string(self):
        """Obtain charge and multiplicity string."""
        return self._get_charge_and_multiplicity()

    def validate_and_assign_level(
        self, functional, basis, force_field, level_name
    ):
        """Validates functional and basis set for a given level
        and returns formatted theory string.
        Return level of theory if both functional and basis are specified,
        or force field if both are not specified.
        """

        if functional and basis and force_field:
            raise ValueError(
                f"For {level_name} level of theory, one should specify only functional/basis or force field!"
            )

        if force_field:
            assert functional is None and basis is None, (
                f"Force field is given for {level_name} level of theory, "
                f"thus no functional and basis should be given!"
            )
            level_of_theory = force_field
        else:
            # if force field is not given, then functional and basis can be given,
            # so that level of theory takes functional and basis set
            if functional and basis:
                level_of_theory = f"{functional}/{basis}"
            else:
                # but functional and basis set can also not be given, in which case,
                # all 3 are None and overall level of theory for that layer is None.
                level_of_theory = None

        logger.debug(
            f"Obtained level of theory {level_of_theory} for {level_name} level."
        )

        return level_of_theory

    def get_qmmm_level_of_theory_string(self):
        """Get ONIOM level of theory for route string."""
        oniom_string = "# oniom"
        assert (
            self.jobtype is not None
        ), "Job type must be specified for ONIOM job!"
        jobtype = self.jobtype.lower()
        jobtype = self.jobtype
        high_level_of_theory = self.validate_and_assign_level(
            self.high_level_functional,
            self.high_level_basis,
            self.high_level_force_field,
            level_name="high",
        )

        medium_level_of_theory = self.validate_and_assign_level(
            self.medium_level_functional,
            self.medium_level_basis,
            self.medium_level_force_field,
            level_name="medium",
        )

        low_level_of_theory = self.validate_and_assign_level(
            self.low_level_functional,
            self.low_level_basis,
            self.low_level_force_field,
            level_name="low",
        )

        if high_level_of_theory is not None:
            oniom_string += f"({high_level_of_theory}"
        if medium_level_of_theory is not None:
            oniom_string += f":{medium_level_of_theory}"
        if low_level_of_theory is not None:
            oniom_string += f":{low_level_of_theory})"
        if jobtype == "sp" or jobtype == "opt" or jobtype == "freq":
            oniom_string += f" {jobtype}"
        # oniom_string += f" {jobtype}"
        return oniom_string

    def _get_charge_and_multiplicity(self):
        """Obtain charge and multiplicity string.
        For two-layer ONIOM jobs, the format for this input line is:

        chrg_real-low spin_real-low [chrg_model-high spin_model-high
                                    [chrg_model-low spin_model-low [chrg_real-high spin_real-high]]]

        Fourth pair applies only to ONIOM=SValue calculations.
        When only a single value pair is specified, all levels will use those values.
        If two pairs of values are included, then third pair defaults to same values as second pair.
        If final pair is omitted for an S-value job, it defaults to values for the real system at low level.
        For such two-layer ONIOM jobs, users are required to specify the charge and multiplicity of high-level
         layer and low-level layer, instead high and medium level.

        For 3-layers ONIOM, the format is:
        cRealL sRealL [cIntM sIntM [cIntL sIntL [cModH sModH [cModM sModM [cModL sModL]]]]]
        Real, Int=Intermediate system, and Mod=Model system, and second character
        is one of: H, M and L for the High, Medium and Low levels).
        """
        assert (
            self.real_charge is not None and self.real_multiplicity is not None
        ), "Charge and multiplicity for the real system must be specified!"
        real_low_charge = self.real_charge
        real_low_multiplicity = self.real_multiplicity
        int_med_charge = self.int_charge
        int_med_multiplicity = self.int_multiplicity
        int_low_charge = self.int_charge
        int_low_multiplicity = self.int_multiplicity
        model_high_charge = self.model_charge
        model_high_multiplicity = self.model_multiplicity
        model_med_charge = self.model_charge
        model_med_multiplicity = self.model_multiplicity
        model_low_charge = self.model_charge
        model_low_multiplicity = self.model_multiplicity

        # two-layer ONIOM model
        if (
            self.validate_and_assign_level(
                self.medium_level_functional,
                self.medium_level_basis,
                self.medium_level_force_field,
                level_name="medium",
            )
            is None
            or self.validate_and_assign_level(
                self.low_level_functional,
                self.low_level_basis,
                self.low_level_force_field,
                level_name="low",
            )
            is None
        ):
            charge_and_multiplicity_list = [
                real_low_charge,
                real_low_multiplicity,
                model_high_charge,
                model_high_multiplicity,
                model_low_charge,
                model_low_multiplicity,
            ]
            if all(var is None for var in charge_and_multiplicity_list[2:]):
                for i in range(2, len(charge_and_multiplicity_list), 2):
                    charge_and_multiplicity_list[i] = real_low_charge
                    charge_and_multiplicity_list[i + 1] = real_low_multiplicity
            elif all(var is None for var in charge_and_multiplicity_list[4:]):
                for i in range(4, len(charge_and_multiplicity_list), 2):
                    charge_and_multiplicity_list[i] = model_high_charge
                    charge_and_multiplicity_list[i + 1] = (
                        model_high_multiplicity
                    )
            elif all(var is not None for var in charge_and_multiplicity_list):
                pass
            else:
                raise ValueError(
                    "The charge and multiplicity of lower level-of-theory cannot override the higher ones!"
                )
            updated_list = []
            for charge_and_multiplicity in charge_and_multiplicity_list:
                updated_list.append(str(charge_and_multiplicity))
            charge_and_multiplicity = " ".join(updated_list)
        else:
            # three-layer ONIOM model
            charge_and_multiplicity_list = [
                real_low_charge,
                real_low_multiplicity,
                int_med_charge,
                int_med_multiplicity,
                int_low_charge,
                int_low_multiplicity,
                model_high_charge,
                model_high_multiplicity,
                model_med_charge,
                model_med_multiplicity,
                model_low_charge,
                model_low_multiplicity,
            ]
            # Defaults for missing charge / spin multiplicity pairs are taken from the next highest
            # calculation level and / or system size.
            if all(var is None for var in charge_and_multiplicity_list[2:]):
                # only charge and multiplicity of real system is specified,
                # so the charge and multiplicity of other systems will be the same as the real system
                for i in range(2, len(charge_and_multiplicity_list), 2):
                    charge_and_multiplicity_list[i] = real_low_charge
                    charge_and_multiplicity_list[i + 1] = real_low_multiplicity
            elif all(var is None for var in charge_and_multiplicity_list[4:]):
                # only charge and multiplicity of real system and that of intermediate layer,
                # medium level-of-theory are specified, the charge and multiplicity of other
                # systems will be the same as the intermediate layer
                for i in range(4, len(charge_and_multiplicity_list), 2):
                    charge_and_multiplicity_list[i] = int_med_charge
                    charge_and_multiplicity_list[i + 1] = int_med_multiplicity
            elif all(var is None for var in charge_and_multiplicity_list[6:]):
                # only charge and multiplicity of real system, intermediate layer, medium level-of-theory
                # and intermediate layer, medium level-of-theory are specified, the charge and multiplicity of other
                # systems will be the same as intermediate layer, medium level-of-theory,...
                for i in range(6, len(charge_and_multiplicity_list), 2):
                    charge_and_multiplicity_list[i] = int_med_charge
                    charge_and_multiplicity_list[i + 1] = int_med_multiplicity
            elif all(var is None for var in charge_and_multiplicity_list[8:]):
                # the rest systems will follow the model system, high level-of-theory
                for i in range(8, len(charge_and_multiplicity_list), 2):
                    charge_and_multiplicity_list[i] = model_high_charge
                    charge_and_multiplicity_list[i + 1] = (
                        model_high_multiplicity
                    )
            elif all(var is None for var in charge_and_multiplicity_list[10:]):
                charge_and_multiplicity_list[-2] = model_med_charge
                charge_and_multiplicity_list[-1] = model_med_multiplicity
            elif all(var is not None for var in charge_and_multiplicity_list):
                pass
            else:
                raise ValueError(
                    "The charge and multiplicity of lower level-of-theory cannot override the higher ones!"
                )
            updated_list = []
            for charge_and_multiplicity in charge_and_multiplicity_list:
                updated_list.append(str(charge_and_multiplicity))
            charge_and_multiplicity = " ".join(updated_list)
        return charge_and_multiplicity
