import copy
import logging
import os
import re

from chemsmart.io.orca import ORCA_ALL_SOLVENT_MODELS
from chemsmart.jobs.settings import MolecularJobSettings
from chemsmart.utils.utils import (
    get_prepend_string_list_from_modred_free_format,
)

logger = logging.getLogger(__name__)


class ORCAJobSettings(MolecularJobSettings):
    """Settings for ORCAJob."""

    def __init__(
        self,
        ab_initio=None,
        functional=None,
        dispersion=None,
        basis=None,
        aux_basis=None,
        extrapolation_basis=None,
        defgrid=None,
        scf_tol=None,
        scf_algorithm=None,
        scf_maxiter=None,
        scf_convergence=None,
        charge=None,
        multiplicity=None,
        gbw=True,
        freq=False,
        numfreq=False,
        dipole=False,
        quadrupole=False,
        mdci_cutoff=None,
        mdci_density=None,
        job_type=None,
        title=None,
        solvent_model=None,
        solvent_id=None,
        additional_route_parameters=None,
        route_to_be_written=None,
        modred=None,
        gen_genecp_file=None,
        heavy_elements=None,
        heavy_elements_basis=None,
        light_elements_basis=None,
        custom_solvent=None,
        forces=False,
        input_string=None,
        invert_constraints=False,
        **kwargs,
    ):
        super().__init__(
            ab_initio=ab_initio,
            functional=functional,
            dispersion=dispersion,
            basis=basis,
            defgrid=defgrid,
            charge=charge,
            multiplicity=multiplicity,
            freq=freq,
            numfreq=numfreq,
            job_type=job_type,
            title=title,
            solvent_model=solvent_model,
            solvent_id=solvent_id,
            additional_route_parameters=additional_route_parameters,
            route_to_be_written=route_to_be_written,
            modred=modred,
            gen_genecp_file=gen_genecp_file,
            heavy_elements=heavy_elements,
            heavy_elements_basis=heavy_elements_basis,
            light_elements_basis=light_elements_basis,
            custom_solvent=custom_solvent,
            forces=forces,
            input_string=input_string,
            **kwargs,
        )

        self.aux_basis = aux_basis
        self.extrapolation_basis = extrapolation_basis
        self.scf_tol = scf_tol
        self.scf_algorithm = scf_algorithm
        self.scf_maxiter = scf_maxiter
        self.scf_convergence = scf_convergence
        self.gbw = gbw
        self.mdci_cutoff = mdci_cutoff
        self.mdci_density = mdci_density
        self.dipole = dipole
        self.quadrupole = quadrupole
        self.invert_constraints = invert_constraints

        if forces is True and (freq is True or numfreq is True):
            raise ValueError(
                "Frequency and Force calculations cannot be performed by Orca at the same time!\n"
                'Such an input file will give "Illegal IType or MSType generated by parse." error.'
            )

    def merge(
        self, other, keywords=("charge", "multiplicity"), merge_all=False
    ):
        """Overwrite self settings with other settings."""

        other_dict = other if isinstance(other, dict) else other.__dict__

        if merge_all:
            # Update self with other for all
            merged_dict = self.__dict__.copy()
            merged_dict.update(other_dict)
            return type(self)(**merged_dict)

        if keywords is not None:
            other_dict = {
                k: other_dict[k] for k in keywords if k in other_dict
            }
        # Update self with other
        merged_dict = self.__dict__.copy()
        merged_dict.update(other_dict)
        return type(self)(**merged_dict)

    def copy(self):
        return copy.deepcopy(self)

    def __getitem__(self, key):
        return self.__dict__[key]

    def __eq__(self, other):
        """Two settings objects are equal if all their attributes are equal."""
        if type(self) is not type(other):
            return NotImplemented

        # Exclude append_additional_info from the comparison
        self_dict = self.__dict__
        self_dict.pop("append_additional_info")

        other_dict = other.__dict__
        other_dict.pop("append_additional_info")

        return self_dict == other_dict

    @classmethod
    def from_comfile(cls, com_path):
        """Return orca job settings from supplied gaussian file."""
        com_path = os.path.abspath(com_path)
        from chemsmart.io.gaussian.input import Gaussian16Input

        logger.info(f"Return Settings object from {com_path}")
        gaussian_settings_from_comfile = Gaussian16Input(
            filename=com_path
        ).read_settings()
        orca_default_settings = cls.default()
        return orca_default_settings.merge(
            gaussian_settings_from_comfile, merge_all=True
        )

    @classmethod
    def from_logfile(cls, log_path, **kwargs):
        """Return Orca input file base settings from gaussian output .log file.

        Args:
            log_path (str): Path to the log file
            kwargs (dict): Additional arguments to be passed to Gaussian16Output class.

        Returns:
            OrcaJobSetting class.
        """
        log_path = os.path.abspath(log_path)
        from chemsmart.io.gaussian.output import Gaussian16Output

        logger.info(f"Return Settings object from {log_path}")
        gaussian_settings_from_logfile = Gaussian16Output(
            log_path
        ).read_settings()
        orca_default_settings = cls.default()
        orca_settings_from_logfile = orca_default_settings.merge(
            gaussian_settings_from_logfile, merge_all=True
        )
        if (
            "def2" in orca_settings_from_logfile.basis
            and "def2-" not in orca_settings_from_logfile.basis
        ):
            orca_settings_from_logfile.basis = (
                orca_settings_from_logfile.basis.replace("def2", "def2-")
            )
        return orca_settings_from_logfile

    @classmethod
    def from_inpfile(cls, inp_path):
        """Return orca job settings from supplied orca .inp file."""
        inp_path = os.path.abspath(inp_path)
        from chemsmart.io.orca.input import ORCAInput

        logger.info(f"Return settings object from {inp_path}")
        orca_settings_from_inpfile = ORCAInput(
            filename=inp_path
        ).read_settings()
        logger.info(f"with settings: {orca_settings_from_inpfile.__dict__}")
        return orca_settings_from_inpfile

    @classmethod
    def from_outfile(cls, out_path):
        """Return orca job settings from supplied orca .out file."""
        out_path = os.path.abspath(out_path)
        from chemsmart.io.orca.output import ORCAOutput

        logger.info(f"Return Settings object from {out_path}")
        return ORCAOutput(filename=out_path).read_settings()

    @classmethod
    def from_xyzfile(cls):
        """Return orca job settings from .xyz file. Default orca settings are used for .xyz input."""
        return ORCAJobSettings.default()

    @classmethod
    def from_filepath(cls, filepath, **kwargs):
        if ".com" in filepath or ".gjf" in filepath:
            return cls.from_comfile(filepath)

        if ".log" in filepath:
            return cls.from_logfile(filepath)

        if ".inp" in filepath:
            return cls.from_inpfile(filepath)

        if ".out" in filepath:
            return cls.from_outfile(filepath)

        if ".xyz" in filepath:
            return cls.from_xyzfile()

        return None

    @classmethod
    def default(cls):
        return cls(
            ab_initio=None,
            functional=None,
            dispersion=None,
            basis=None,
            aux_basis=None,
            extrapolation_basis=None,
            defgrid=None,
            scf_tol=None,
            scf_algorithm=None,
            scf_maxiter=None,
            scf_convergence=None,
            charge=None,
            multiplicity=None,
            gbw=True,
            freq=True,
            numfreq=False,
            mdci_cutoff=None,
            mdci_density=None,
            job_type=None,
            title=None,
            solvent_model=None,
            solvent_id=None,
            additional_route_parameters=None,
            route_to_be_written=None,
            modred=None,
            gen_genecp_file=None,
            heavy_elements=None,
            heavy_elements_basis=None,
            light_elements_basis=None,
            custom_solvent=None,
            forces=False,
            input_string=None,
            invert_constraints=False,
        )

    @property
    def route_string(self):
        if self.route_to_be_written is not None:
            route_string = self._get_route_string_from_user_input()
        else:
            route_string = self._get_route_string_from_jobtype()
        logger.debug(f"Route for settings {self}: {route_string}")
        return route_string

    def _get_route_string_from_user_input(self):
        route_string = self.route_to_be_written
        if not route_string.startswith("!"):
            route_string = f"! {route_string}"
        return route_string

    def _get_route_string_from_jobtype(self):
        """Get the ORCA job route string from the ORCA job type."""
        route_string = ""
        if not route_string.startswith("!"):
            route_string += "! "

        # route string depends on job type
        # determine if route string requires 'opt' keyword
        if self.job_type in ("opt", "modred", "scan"):
            route_string += "Opt"
        elif self.job_type == "ts":
            route_string += (
                "OptTS"  # Orca keyword for transition state optimization
            )
        elif self.job_type == "irc":
            route_string += "IRC"
        elif self.job_type == "sp":
            route_string += ""

        # add frequency calculation
        # not okay if both freq and numfreq are True
        if self.freq and self.numfreq:
            raise ValueError("Cannot specify both freq and numfreq!")

        if self.freq:
            route_string += " Freq"
        elif self.numfreq:
            route_string += " NumFreq"  # requires numerical frequency,
            # e.g., in SMD model where analytic Hessian is not available

        # write level of theory
        level_of_theory = self._get_level_of_theory()
        route_string += f" {level_of_theory}"

        # write grid information
        if self.defgrid is not None:
            route_string += (
                f" {self.defgrid}"  # default is 'defgrid2', if not specified
            )

        # write convergence criteria in simple input/route
        if self.scf_tol is not None:
            if not self.scf_tol.lower().endswith("scf"):
                self.scf_tol += "SCF"
            route_string += f" {self.scf_tol}"

        # write convergence algorithm if not default
        if self.scf_algorithm is not None:
            route_string += f" {self.scf_algorithm}"

        # write solvent if solvation is turned on
        if self.solvent_model is not None and self.solvent_id is not None:
            route_string += f" {self.solvent_model}({self.solvent_id})"
        elif self.solvent_model is not None and self.solvent_id is None:
            raise ValueError(
                "Warning: Solvent model is specified but solvent identity is missing!"
            )
        elif self.solvent_model is None and self.solvent_id is not None:
            logger.warning(
                "Warning: Solvent identity is specified but solvent model is missing!\n"
                "Defaulting to CPCM model."
            )
            route_string += f" CPCM({self.solvent_id})"
        else:
            pass

        return route_string

    def _get_level_of_theory(self):
        level_of_theory = ""
        if self.ab_initio is not None and self.functional is not None:
            raise ValueError(
                "Warning: both ab initio and DFT are specified!\nPlease specify only one method!"
            )

        if self.ab_initio is None and self.functional is None:
            raise ValueError(
                "Warning: neither ab initio nor DFT is specified!\nPlease specify one method!"
            )

        if self.ab_initio is not None:
            level_of_theory += f"{self.ab_initio}"
        elif self.functional is not None:
            level_of_theory += f"{self.functional}"

        if self.basis is not None:
            level_of_theory += f" {self.basis}"
        elif self.basis is None:
            raise ValueError("Warning: basis is missing!")

        if self.aux_basis is not None:
            level_of_theory += f" {self.aux_basis}"

        if self.extrapolation_basis is not None:
            level_of_theory += f" {self.extrapolation_basis}"
        return level_of_theory

    def _write_geometry(self, f, atoms):
        # check that both charge and multiplicity are specified
        assert self.charge is not None, "No charge found!"
        assert self.multiplicity is not None, "No multiplicity found!"
        f.write(f"* xyz {self.charge} {self.multiplicity}\n")

        # check that a molecular geometry is given
        assert atoms is not None, "No molecular geometry found!"
        logger.info(f"Molecule given is: {atoms}")

        coordinates = ""
        for _i, (s, (x, y, z)) in enumerate(
            zip(atoms.symbols, atoms.positions, strict=False)
        ):
            string = f"{s:5} {float(x):15.10f} {float(y):15.10f} {float(z):15.10f}\n"
            coordinates += string
        f.write(coordinates)
        f.write("*\n")

    def _check_solvent(self, solvent_model):
        if solvent_model.lower() not in ORCA_ALL_SOLVENT_MODELS:
            raise ValueError(
                f"The specified solvent model {solvent_model} is not in \n"
                f"the available solvent models: {ORCA_ALL_SOLVENT_MODELS}"
            )


class ORCATSJobSettings(ORCAJobSettings):
    def __init__(
        self,
        inhess=False,
        inhess_filename=None,
        hybrid_hess=False,
        hybrid_hess_atoms=None,
        numhess=False,
        recalc_hess=5,
        trust_radius=None,
        tssearch_type="optts",
        scants_modred=None,
        full_scan=False,
        **kwargs,
    ):
        super().__init__(**kwargs)
        self.inhess = inhess
        self.inhess_filename = inhess_filename
        self.hybrid_hess = hybrid_hess
        self.hybrid_hess_atoms = (
            hybrid_hess_atoms  # supplied a list; 1-indexed as per user
        )
        self.numhess = numhess
        self.recalc_hess = recalc_hess
        self.trust_radius = trust_radius
        self.tssearch_type = (
            tssearch_type  # methods for TS search: OptTS, ScanTS
        )
        self.scants_modred = (
            scants_modred  # modred for scanTS (as in a scan job)
        )
        self.full_scan = full_scan  # full scan or not;  do or not abort scan after highest point is reached

    @property
    def route_string(self):
        """Get the ORCA job route string for ORCA TS job; overrides parent property."""
        self.job_type = "ts"
        route_string = self._get_route_string_from_jobtype()
        if self.tssearch_type.lower() == "scants":
            route_string = route_string.replace("OptTS", "ScanTS")
        return route_string


class ORCAIRCJobSettings(ORCAJobSettings):
    def __init__(
        self,
        maxiter=None,
        printlevel=None,
        direction=None,
        inithess=None,
        hess_filename=None,
        hessmode=None,
        init_displ=None,
        scale_init_displ=None,
        de_init_displ=None,
        follow_coordtype=None,
        scale_displ_sd=None,
        adapt_scale_displ=None,
        sd_parabolicfit=None,
        interpolate_only=None,
        do_sd_corr=None,
        scale_displ_sd_corr=None,
        sd_corr_parabolicfit=None,
        tolrmsg=None,
        tolmaxg=None,
        monitor_internals=None,
        internal_modred=None,
        **kwargs,
    ):
        super().__init__(**kwargs)
        self.maxiter = maxiter
        self.printlevel = printlevel
        self.direction = direction
        self.inithess = inithess
        self.hess_filename = hess_filename
        self.hessmode = hessmode
        self.init_displ = init_displ
        self.scale_init_displ = scale_init_displ
        self.de_init_displ = de_init_displ
        self.follow_coordtype = follow_coordtype
        self.scale_displ_sd = scale_displ_sd
        self.adapt_scale_displ = adapt_scale_displ
        self.sd_parabolicfit = sd_parabolicfit
        self.interpolate_only = interpolate_only
        self.do_sd_corr = do_sd_corr
        self.scale_displ_sd_corr = scale_displ_sd_corr
        self.sd_corr_parabolicfit = sd_corr_parabolicfit
        self.tolrmsg = tolrmsg
        self.tolmaxg = tolmaxg
        self.monitor_internals = monitor_internals
        self.internal_modred = internal_modred

    @property
    def route_string(self):
        """Get the ORCA job route string for ORCA IRC job; overrides parent property."""
        self.job_type = "irc"
        route_string = self._get_route_string_from_jobtype()
        if "freq" in route_string.lower():
            route_string = re.sub(
                r"freq", "", route_string, flags=re.IGNORECASE
            )
        return route_string

    def _write_irc_block(self, f):
        """Writes the IRC block options.

        IRC block input example below:
        ! IRC
        %irc
            MaxIter    20
            PrintLevel 1
            Direction  both # both - default
                            # forward
                            # backward
                            # down
        # Initial displacement
            InitHess   read # by default ORCA uses the Hessian from AnFreq or NumFreq, or computes a new one
                            # read    - reads the Hessian that is defined via Hess_Filename
                            # calc_anfreq  - computes the analytic Hessian
                            # calc_numfreq - computes the numeric Hessian
            Hess_Filename "h2o.hess"  # Hessian for initial displacement, must be used together with InitHess = read
            hessMode   0  # Hessian mode that is used for the initial displacement. Default 0
            Init_Displ DE      # DE (default) - energy difference
                               # length       - step size
            Scale_Init_Displ 0.1 # step size for initial displacement from TS. Default 0.1 a.u.
            DE_Init_Displ    2.0 # energy difference that is expected for initial displacement
                                 #  based on provided Hessian (Default: 2 mEh)
        # Steps
            Follow_CoordType cartesian # default and only option
            Scale_Displ_SD    0.15  # Scaling factor for scaling the 1st SD step
            Adapt_Scale_Displ true  # modify Scale_Displ_SD when the step size becomes smaller or larger
            SD_ParabolicFit   true  # Do a parabolic fit for finding an optimal SD step length
            Interpolate_only  true  # Only allow interpolation for parabolic fit, not extrapolation
            Do_SD_Corr        true  # Apply a correction to the 1st SD step
            Scale_Displ_SD_Corr  0.333 # Scaling factor for scaling the correction step to the SD step.
                                       # It is multiplied by the length of the final 1st SD step
            SD_Corr_ParabolicFit true  # Do a parabolic fit for finding an optimal correction
                                       # step length
        # Convergence thresholds - similar to LooseOpt
            TolRMSG   5.e-4      # RMS gradient (a.u.)
            TolMaxG   2.e-3      # Max. element of gradient (a.u.)
        # Output options
            Monitor_Internals   # Up to three internal coordinates can be defined
                {B 0 1}         # for which the values are printed during the IRC run.
                {B 1 5}         # Possible are (B)onds, (A)ngles, (D)ihedrals and (I)mpropers
            end
        end.
        """
        irc_settings_keys = ORCAIRCJobSettings().__dict__.keys()
        parent_settings_keys = ORCAJobSettings().__dict__.keys()
        irc_specific_keys = set(irc_settings_keys) - set(parent_settings_keys)

        if not any(
            getattr(self, key) is not None for key in irc_specific_keys
        ):
            return

        # write irc block if any option value is not None:
        f.write("%irc\n")
        for key in irc_specific_keys:
            value = getattr(self, key)
            if value is None:
                continue  # ignore the rest of the code and go to next in the for loop
            # only write into IRC input if the value is not None
            if key == "internal_modred":
                pass  # internal_modred is not an option in ORCA IRC file
            elif key == "inithess":
                f.write(f"  {key} {value}\n")
                if value.lower() == "read":  # if initial hessian is to be read
                    assert (
                        self.hess_filename is not None
                    ), "No Hessian file is given!"
                    assert os.path.exists(
                        self.hess_filename
                    ), f"Hessian file {self.hess_filename} is not found!"
                    f.write(
                        f'  Hess_Filename "{self.hess_filename}"  # Hessian file\n'
                    )
            elif (
                key == "hess_filename"
            ):  # already used/written, if initial hessian is to be read
                pass
            elif key == "monitor_internals":
                if str(value).lower() == "true":
                    f.write(f"  {key}\n")
                    assert (
                        self.internal_modred is not None
                    ), 'No internal modred is specified for IRC job "monitor_intervals" option!'
                    prepend_string_list = (
                        get_prepend_string_list_from_modred_free_format(
                            self.internal_modred, program="orca"
                        )
                    )
                    for prepend_string in prepend_string_list:
                        f.write(f"  {{ {prepend_string} }}\n")
                    f.write("  end\n")
                else:  # monitor_internals has other value (false), then don't write it in input
                    pass
            else:  # all other keys with given values
                f.write(f"  {key} {value}\n")
        f.write("end\n")


class ORCAQMMMJobSettings(ORCAJobSettings):
    """Settings for ORCA multiscale job.
    This includes five types of methods:
    1. Additive QMMM.
    2. Subtractive QM/QM2 (2-layered ONIOM).
    3. Subtractive QM/QM2/MM (3-layered ONIOM).
    4. MOL-CRYSTAL-QMMM for molecular crystals.
    5. IONIC-CRYSTAL-QMMM for semiconductors and insulators."""

    def __init__(
        self,
        jobtype=None,  # corresponding to the 5 types of jobs mentioned above
        qm_functional=None,
        qm_basis=None,
        qm2_functional=None,
        qm2_basis=None,
        qm2_method=None,
        mm_force_field=None,  # level-of-theory for MM
        qm_atoms=None,
        qm2_atoms=None,
        charge_total=None,
        mult_total=None,
        charge_medium=None,
        mult_medium=None,
        charge_qm=None,
        mult_qm=None,
        qm2_solvation=None,
        active_atoms=None,
        use_active_info_from_pbc=False,
        optregion_fixed_atoms=None,
        qm_h_bond_length=None,  # similar to scale factors in Gaussian ONIOM jobs
        delete_la_double_counting=False,
        delete_la_bond_double_counting_atoms=False,
        embedding_type=None,  # optional
        # the followings are crystal QM/MM parameters
        conv_charges=True,
        conv_charges_max_n_cycles=None,
        conv_charges_conv_thresh=None,
        scale_formal_charge_mm_atom=None,
        n_unit_cell_atoms=None,  # for MOL-CRYSTAL-QMMM jobs
        # the followings are for INONIC-CRYSTAL-QMMM jobs
        ecp_layer_ecp=None,
        ecp_layer=None,
        scale_formal_charge_ecp_atom=None,
        **kwargs,
    ):
        """
        Args:
            jobtype: str, type of multiscale job (e.g. "QMMM", "QM/QM2", "QM/QM2/MM", "MOL-CRYSTAL-QMMM", "IONIC-CRYSTAL-QMMM")
            qm_functional: str, functional for QM level of theory
            qm_basis: str, basis set for QM level of theory
            qm2_functional: str, functional for QM2 level of theory
            qm2_basis: str, basis set for QM2 level of theory
            qm2_method: str, method for QM2 level of theory (e.g. "XTB", "HF-3C", "PBEH-3C")
            mm_force_field: str, method for MM level of theory (e.g. "MMFF", "AMBER", "CHARMM")
            qm_atoms: list of int, indices of QM atoms
            qm2_atoms: list of int, indices of QM2 atoms
            charge_total: int, total charge of the system
            mult_total: int, total multiplicity of the system
            charge_medium: int, charge of the medium system (QM2) if available
            mult_medium: int, multiplicity of the medium system (QM2) if available
            charge_qm: int, charge of the QM system
            mult_qm: int, multiplicity of the QM system
            qm2_solvation: str, solvation model for QM2 level of theory (e.g. "CPCM", "SMD")
            active_atoms: list of int, indices of active atoms in the system, default whole system
            optregion_fixed_atoms: list of int, indices of fixed atoms in the optimization region
            qm_h_bond_length: dictionary, where the key is atom types of two bonding atoms (in tuple), and values are customized bond length
            delete_la_double_counting: bool, whether to neglect bends (QM2-QM1-MM1) and torsions (QM3-QM2-QM1-MM1), default true
            delete_la_bond_double_counting_atoms: bool, whether to neglect bonds (QM1-MM1), default true
            electronic_interaction: str, whether to use electronic (default)/mechanical embedding between QM and MM region
            conv_charges: bool, default true
            conv_charges_max_n_cycles: int, default 30 for MOL-CRYSTAL-QMMM, 10 for IONIC-CRYSTAL-QMMM
            conv_charges_conv_thresh: float, default 1e-2 for maximum charge change for atom type between two subsequent charge convergence cycles
            scale_formal_charge_mm_atom: float, scale factors of MM atomic charges used in QM part of the CRYSTAL-QMMM calculation, default 1.
            n_unit_cell_atoms: int, the number of atoms per molecular subunit. Mandatory for MOL-CRYSTAL-QMMM
            ecp_layer_ecp: str, cECPs used for the boundary region
            ecp_layer: int, number of cECP layers around the QM region, default 3
            scale_formal_charge_ecp_atom: float, scale factors of ECP atomic charges, default 1.

        """
        super().__init__(**kwargs)
        self.jobtype = jobtype
        self.qm_functional = qm_functional
        self.qm_basis = qm_basis
        self.qm2_functional = qm2_functional
        self.qm2_basis = qm2_basis
        self.qm2_method = qm2_method
        self.mm_method = mm_force_field
        self.qm_atoms = qm_atoms
        self.qm2_atoms = qm2_atoms
        self.charge_total = charge_total
        self.mult_total = mult_total
        self.charge_medium = charge_medium
        self.mult_medium = mult_medium
        self.charge_qm = charge_qm
        self.mult_qm = mult_qm
        self.qm2_solvation = qm2_solvation
        self.active_atoms = active_atoms
        self.use_active_info_from_pbc = use_active_info_from_pbc
        self.optregion_fixed_atoms = optregion_fixed_atoms
        self.qm_h_bond_length = qm_h_bond_length
        self.delete_la_double_counting = delete_la_double_counting
        self.delete_la_bond_double_counting_atoms = (
            delete_la_bond_double_counting_atoms
        )
        self.embedding_type = embedding_type
        self.conv_charges = conv_charges
        self.conv_charges_max_n_cycles = conv_charges_max_n_cycles
        self.conv_charges_conv_thresh = conv_charges_conv_thresh
        self.scale_formal_charge_mm_atom = scale_formal_charge_mm_atom
        self.n_unit_cell_atoms = n_unit_cell_atoms
        self.ecp_layer_ecp = ecp_layer_ecp
        self.ecp_layer = ecp_layer
        self.scale_formal_charge_ecp_atom = scale_formal_charge_ecp_atom

        # populate self.functional, self.basis, etc.
        self.functional = self.qm_functional
        self.basis = self.qm_basis
        if self.charge_medium is not None and self.mult_medium is not None:
            self.charge = self.charge_medium
            self.multiplicity = self.mult_medium
            # the charge/multiplicity of the medium system corresponds to the
            # sum of the charge/multiplicity of the high level and low level regions
        else:
            self.charge = self.charge_qm
            self.multiplicity = self.mult_qm

    @property
    def qmmm_block(self):
        return self._write_qmmm_block()

    def validate_and_assign_level(
        self, functional, basis, built_in_method, level_name
    ):
        """Validate and assign the level of theory for QM and QM2."""
        qm2_built_in_list = [
            "XTB",
            "XTB0",
            "XTB1",
            "HF-3C",
            "PBEH-3C",
            "R2SCAN-3C",
            "PM3",
            "AM1",
        ]
        level_of_theory = ""
        if functional and basis and built_in_method:
            raise ValueError(
                f"For {level_name} level of theory, one should specify only functional/basis or ORCA built-in method!"
            )
        if built_in_method:
            assert functional is None and basis is None, (
                f"ORCA built-in method is given for {level_name} level of theory, "
                f"thus no functional and basis should be given!"
            )
            if (
                level_name == "qm2"
                and built_in_method.upper() in qm2_built_in_list
            ):
                level_of_theory = built_in_method
        elif functional and basis:
            if level_name == "qm2":
                level_of_theory = "QM2"
            else:
                level_of_theory = f"{functional} {basis}"
        else:
            level_of_theory = None
        logger.debug(
            f"Obtained level of theory {level_of_theory} for {level_name} level."
        )
        return level_of_theory

    def check_crystal_qmmm(self):
        job_type = self.job_type.upper()
        if job_type in ["IONIC-CRYSTAL-QMMM", "MOL-CRYSTAL-QMMM"]:
            assert (
                self.mult_qm is None
                and self.mult_medium is None
                and self.mult_total is None
            ), f"Multiplicity should not be specified for {job_type} job!"
            self.multiplicity = 0  # avoid conflicts from parent class
            if self.conv_charges is False:
                assert (
                    self.mm_method is not None
                ), "Force field file containing convergence charges is not provided!"
            if job_type == "MOL-CRYSTAL-QMMM":
                assert (
                    self.n_unit_cell_atoms
                ), f"The number of atoms per molecular subunit for {job_type} job is not provided!"
            else:
                assert (
                    self.ecp_layer_ecp
                ), f"cECPs used for the boundary region for {job_type} job must be specified! "
                assert (
                    self.n_unit_cell_atoms is None
                ), f"The number of atoms per molecular subunit is only applicable to MOL-CRYSTAL-QMMM!"

    def _get_level_of_theory_string(self):
        """Get the level of theory string for QM and QM2.
        e.g. '!QM/XTB' (without solvent), '!QM/XTB ALPB(Water)' (with solvent), '!QM/HF-3C/MM' (for QM/QM2/MM)
        """
        # todo: move to crystalqmmm class
        if (
            self.job_type.upper() == "IONIC-CRYSTAL-QMMM"
            or self.job_type.upper() == "MOL-CRYSTAL-QMMM"
        ):
            level_of_theory = f"! {self.job_type.upper()}"
        else:
            level_of_theory = "!QM"
            self.qm_level_of_theory = self.validate_and_assign_level(
                self.qm_functional, self.qm_basis, None, level_name="qm"
            )
            self.qm2_level_of_theory = self.validate_and_assign_level(
                self.qm2_functional,
                self.qm2_basis,
                self.qm2_method,
                level_name="qm2",
            )
            self.mm_level_of_theory = self.validate_and_assign_level(
                None, None, self.mm_method, level_name="mm"
            )
            if self.qm2_level_of_theory is not None:
                level_of_theory += f"/{self.qm2_level_of_theory}"
            if self.mm_level_of_theory is not None:
                if self.job_type.upper() == "QMMM":
                    # only "!QMMM" will be used for additive QMMM
                    level_of_theory = "!QMMM"
                else:
                    level_of_theory += f"/{self.mm_level_of_theory}"
            if self.solvent_model is not None:
                level_of_theory += f" {self.solvent_model}"
            if self.qm2_method.lower() == "xtb" and self.qm2_solvation in [
                "ALPB(Water)",
                "DDCOSMO(Water)",
                "CPCMX(Water)",
            ]:
                level_of_theory += f" {self.qm2_solvation}"
            elif (
                self.qm2_level_of_theory != "QM2"
                and self.qm2_solvation == "CPCM(Water)"
            ):
                level_of_theory += f" {self.qm2_solvation}"
            return level_of_theory

    def _get_h_bond_length(self):
        """Example input in '%qmmm' block:
        %qmmm
        # standard equilibrium bond lengths with hydrogen can be modified
        Dist_C_HLA 1.09 # d0_C-H
        Dist_O_HLA 0.98 # d0_O-H
        Dist_N_HLA 0.99 # d0_N-H
        # file can be provided which provides the used d0_X-H values specific to all atoms
        H_Dist_FileName "QM_H_dist.txt"
        end
        """
        if isinstance(self.qm_h_bond_length, dict):
            h_bond_length = ""
            for atom_pair, bond_length in self.qm_h_bond_length.items():
                h_bond_length += (
                    f"Dist_{atom_pair[0]}_{atom_pair[1]} {bond_length}\n"
                )
            return h_bond_length
        elif isinstance(self.qm_h_bond_length, str):
            # if the user provided a file with the d0_X-H values
            assert os.path.exists(
                self.qm_h_bond_length
            ), f"File {self.qm_h_bond_length} does not exist!"
            return f'H_Dist_FileName "{self.qm_h_bond_length}"'

    def _get_embedding_type(self):
        embedding_type = "Embedding "
        if self.embedding_type.lower() == "electronic":
            embedding_type += "Electronic"
        elif self.embedding_type.lower() == "mechanical":
            embedding_type += "Mechanical"
        else:
            raise ValueError(
                f"Invalid embedding type: {self.embedding_type}. "
                "Valid options are 'Electronic' or 'Mechanical'."
            )
        return embedding_type

    def _get_charge_and_multiplicity(self):
        """Get the charge and multiplicity of total system (for QM/MM) or QM2 (for QM/QM2/MM).
        note that in ORCA multiscale jobs the total/medium charge/multiplicity is specified in %qmmm block,
        and QM charge/multiplicity are specified in the coordination block"""
        if self.qm2_atoms is not None:
            charge = f"Charge_Medium {self.charge_medium}"
            mult = f"Mult_Medium {self.mult_medium}"
        else:
            charge = f"Charge_Total {self.charge_total}"
            mult = f"Mult_Total {self.mult_total}"
        return charge, mult

    def _write_qmmm_block(self):
        """Writes the QMMM block options.

        QMMM block input example below:
        !QM/HF-3c/MM Opt B3LYP def2-TZVP def2/J NumFreq
        %qmmm
        ORCAFFFilename "peptideChain.ORCAFF.prms"
        QMAtoms {16:33 68:82} end
        QM2Atoms {0:12 83:104} end
        ActiveAtoms { 0:38 65:120} end
        Charge_Medium 0
        end
        *pdbfile -1 1 peptideChain.pdb
        """
        qm_block = {}
        full_qm_block = "%qmmm\n"
        qm_block["qm_atoms"] = f"QMAtoms {''.join(self.qm_atoms)} end "
        if self.qm2_atoms:
            qm_block["qm2_atoms"] = f"QM2Atoms {''.join(self.qm2_atoms)} end "
        qm_block["charge"], _ = self._get_charge_and_multiplicity()
        _, qm_block["multiplicity"] = self._get_charge_and_multiplicity()
        if self.qm2_solvation is not None:
            qm_block["qm2_solvation"] = f"solv_scheme {self.qm2_solvation}"
        if self.active_atoms is not None:
            qm_block["active_atoms"] = (
                f"ActiveAtoms {''.join(self.active_atoms)} end"
            )
        if self._get_level_of_theory() in ["!QM/QM2", "!QM/QM2/MM"]:
            if self.qm2_method is not None:
                # the case where QM2 method is provided in a file
                qm_block["qm2_method"] = (
                    f'QM2CustomFile "{self.qm2_method}" end'
                )
            else:
                qm_block["qm2_funtional"] = (
                    f'QM2CUSTOMMETHOD "{self.qm2_functional}" end'
                )
                qm_block["qm2_basis"] = (
                    f'QM2CUSTOMBASIS "{self.qm2_basis}" end'
                )

        if self.jobtype.upper() in [
            "QM/MM",
            "QM/QM2/MM",
            "IONIC-CRYSTAL-QMMM",
        ]:
            assert (
                self.mm_method is not None
            ), f"Force field file is missing for {self.jobtype} job!"
            qm_block["force_field"] = f'ORCAFFFilename "{self.mm_method}"'

        if self.use_active_info_from_pbc == True:
            qm_block["fixed_atoms"] = "Use_Active_InfoFromPDB true"
        elif self.active_atoms:
            qm_block["fixed_atoms"] = (
                f"OptRegion_FixedAtoms {''.join(self.optregion_fixed_atoms)} end"
            )
        if self.qm_h_bond_length is not None:
            qm_block["h_bond_length"] = self._get_h_bond_length()
        if self.delete_la_double_counting is True:
            qm_block["delete_la_double_counting"] = (
                "Delete_LA_Double_Counting true"
            )
        if self.delete_la_bond_double_counting_atoms is True:
            qm_block["delete_la_bond_double_counting_atoms"] = (
                "DeleteLABondDoubleCounting true"
            )
        if self.embedding_type is not None:
            qm_block["embedding_type"] = self._get_embedding_type()
        for key, val in qm_block:
            full_qm_block += f"{val}\n"
        if self._write_crystal_qmmm_subblock() is not None:
            full_qm_block += self._write_crystal_qmmm_subblock()
        full_qm_block += f"end\n"
        return full_qm_block

    def _write_crystal_qmmm_subblock(self):
        crystal_qmmm_subblock = " "
        if self.conv_charges is False:
            crystal_qmmm_subblock += "Conv_Charges False \n"
            crystal_qmmm_subblock += f'ORCAFFFilename "{self.mm_method}" \n'
        if self.conv_charges_max_n_cycles is not None:
            crystal_qmmm_subblock += (
                f"Conv_Charges_MaxNCycles {self.conv_charges_max_n_cycles} \n"
            )
        if self.conv_charges_conv_thresh is not None:
            crystal_qmmm_subblock += (
                f"Conv_Charges_ConvThresh {self.conv_charges_conv_thresh} \n"
            )
        if self.scale_formal_charge_mm_atom is not None:
            crystal_qmmm_subblock += f"Scale_FormalCharge_MMAtom {self.scale_formal_charge_mm_atom} \n"
        if self.n_unit_cell_atoms is not None:
            crystal_qmmm_subblock += (
                f"NumUnitCellAtoms {self.n_unit_cell_atoms} \n"
            )
        if self.ecp_layer_ecp is not None:
            crystal_qmmm_subblock += f"cECPs {self.ecp_layer_ecp} \n"
        if self.ecp_layer is not None:
            crystal_qmmm_subblock += f"ECPLayers {self.ecp_layer} \n"
        if self.scale_formal_charge_ecp_atom is not None:
            crystal_qmmm_subblock += f"Scale_FormalCharge_ECPAtom {self.scale_formal_charge_ecp_atom} \n"
        return crystal_qmmm_subblock
